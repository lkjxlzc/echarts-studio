<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŸ©å½¢å›¾ç‰‡ç”Ÿæˆå™¨</title>
    <meta name="description" content="ä½¿ç”¨ ECharts custom ç³»åˆ—æ¸²æŸ“é«˜å“è´¨æ•°æ®è¡¨æ ¼ï¼Œæ”¯æŒå®æ—¶é¢„è§ˆä¸é«˜æ¸…å¯¼å‡º">

    <!-- ECharts 5 -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FileSaver for export -->
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <!-- JSZip for split export -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['-apple-system', 'BlinkMacSystemFont', '"SF Pro Display"', '"Segoe UI"', 'Roboto', 'sans-serif'],
                        mono: ['"SF Mono"', '"Cascadia Code"', '"Fira Code"', 'Consolas', 'monospace'],
                    },
                    colors: {
                        apple: {
                            bg: '#f5f5f7',
                            surface: '#ffffff',
                            border: 'rgba(0,0,0,0.06)',
                            text: '#1d1d1f',
                            secondary: '#86868b',
                            tertiary: '#aeaeb2',
                            blue: '#007aff',
                            green: '#34c759',
                            red: '#ff3b30',
                            orange: '#ff9500',
                        }
                    }
                }
            }
        }
    </script>

    <style>
        /* â”€â”€ Glassmorphism & Premium Overrides â”€â”€ */
        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.82);
            backdrop-filter: blur(40px) saturate(200%);
            -webkit-backdrop-filter: blur(40px) saturate(200%);
        }

        .preview-grid {
            background-image: radial-gradient(circle at 1px 1px, rgba(0, 0, 0, 0.06) 1px, transparent 0);
            background-size: 20px 20px;
        }

        /* â”€â”€ Custom scrollbar â”€â”€ */
        .slim-scroll::-webkit-scrollbar {
            width: 4px;
        }

        .slim-scroll::-webkit-scrollbar-track {
            background: transparent;
        }

        .slim-scroll::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.15);
            border-radius: 99px;
        }

        .slim-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.25);
        }

        /* â”€â”€ iOS Toggle Switch â”€â”€ */
        .ios-toggle {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 26px;
            flex-shrink: 0;
        }

        .ios-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }

        .ios-toggle .slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background: rgba(120, 120, 128, 0.2);
            border-radius: 26px;
            transition: background 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .ios-toggle .slider::before {
            content: '';
            position: absolute;
            left: 2px;
            top: 2px;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15), 0 1px 1px rgba(0, 0, 0, 0.06);
            transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .ios-toggle input:checked+.slider {
            background: #007aff;
        }

        .ios-toggle input:checked+.slider::before {
            transform: translateX(18px);
        }

        /* â”€â”€ Range slider Apple style â”€â”€ */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 99px;
            outline: none;
            background: linear-gradient(90deg, rgba(0, 122, 255, 0.15), rgba(120, 120, 128, 0.2));
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            border: none;
            cursor: pointer;
            box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1), 0 1px 4px rgba(0, 0, 0, 0.12), 0 0 0 0.5px rgba(0, 0, 0, 0.04);
            transition: transform 0.18s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.12);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(0.95);
        }

        /* â”€â”€ Button Spring â”€â”€ */
        .btn-spring {
            transition: all 0.22s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .btn-spring:hover {
            transform: translateY(-0.5px);
        }

        .btn-spring:active {
            transform: scale(0.97) translateY(0.5px);
            transition-duration: 0.08s;
        }

        /* â”€â”€ Zoom toolbar glass â”€â”€ */
        .zoom-bar {
            background: rgba(255, 255, 255, 0.72);
            backdrop-filter: blur(24px) saturate(200%);
            -webkit-backdrop-filter: blur(24px) saturate(200%);
            border: 0.5px solid rgba(255, 255, 255, 0.5);
        }

        /* â”€â”€ Fade-in animation â”€â”€ */
        @keyframes fadeUp {
            from {
                opacity: 0;
                transform: translateY(8px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-up {
            animation: fadeUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) both;
        }

        /* â”€â”€ Color swatch ring â”€â”€ */
        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            width: 36px;
            height: 36px;
            border: none;
            padding: 0;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.08), 0 2px 6px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s;
        }

        input[type="color"]:hover {
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.3), 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 2px;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        /* â”€â”€ Font Dropdown (sync with table.html) â”€â”€ */
        .font-dropdown-list {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            margin-top: 4px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            max-height: 220px;
            overflow-y: auto;
            z-index: 1000;
            padding: 4px;
            list-style: none;
            display: none;
            margin-bottom: 0;
            box-sizing: border-box;
        }

        .font-dropdown-list.show {
            display: block;
        }

        .font-dropdown-item {
            padding: 7px 10px;
            font-size: 12px;
            color: #1d1d1f;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.1s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0;
        }

        .font-dropdown-item:hover,
        .font-dropdown-item.active {
            background: #007AFF;
            color: #fff;
        }

        #ai-status.success-toast {
            animation: status-success 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes status-success {
            0% {
                transform: translateY(10px);
                opacity: 0;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* â”€â”€ Image Color Picker â”€â”€ */
        .img-upload-area {
            border: 1.5px dashed rgba(0, 122, 255, 0.3);
            border-radius: 12px;
            padding: 14px 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0, 122, 255, 0.03);
            position: relative;
        }

        .img-upload-area:hover {
            border-color: rgba(0, 122, 255, 0.6);
            background: rgba(0, 122, 255, 0.06);
        }

        .img-upload-area input[type=file] {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .color-swatches-row {
            display: flex;
            gap: 6px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15), inset 0 0 0 1px rgba(0, 0, 0, 0.08);
            transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.15s;
            flex-shrink: 0;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.18);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
            z-index: 2;
        }

        .color-swatch .swatch-edit-icon {
            position: absolute;
            bottom: -3px;
            right: -3px;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.15s;
            pointer-events: none;
        }

        .color-swatch:hover .swatch-edit-icon {
            opacity: 1;
        }

        #color-img-preview {
            width: 100%;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
            display: none;
            margin-top: 8px;
        }

        .color-swatch-label {
            font-size: 9px;
            font-weight: 600;
            text-align: center;
            margin-top: 3px;
            color: #86868b;
            font-family: monospace;
            letter-spacing: -0.02em;
        }

        /* â”€â”€ Color Scheme Cards â”€â”€ */
        .scheme-card {
            border: 1.5px solid rgba(0, 0, 0, 0.07);
            border-radius: 12px;
            padding: 10px 10px 8px;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.015);
            transition: border-color 0.18s, box-shadow 0.18s;
            cursor: pointer;
        }

        .scheme-card:hover {
            border-color: rgba(0, 122, 255, 0.35);
            box-shadow: 0 2px 12px rgba(0, 122, 255, 0.08);
        }

        .scheme-card.selected {
            border-color: #007aff;
            background: rgba(0, 122, 255, 0.04);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.12);
        }

        .scheme-strip {
            display: flex;
            height: 18px;
            border-radius: 6px;
            overflow: hidden;
            margin: 6px 0 7px;
        }

        .scheme-strip span {
            flex: 1;
            display: block;
        }

        .scheme-apply-btn {
            width: 100%;
            padding: 5px 0;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            background: linear-gradient(to bottom, #0a84ff, #007aff);
            color: #fff;
            border: none;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .scheme-apply-btn:hover {
            opacity: 0.85;
        }

        .scheme-apply-btn.outline {
            background: transparent;
            color: #007aff;
            border: 1.5px solid rgba(0, 122, 255, 0.35);
        }

        .scheme-apply-btn.outline:hover {
            background: rgba(0, 122, 255, 0.06);
        }

        /* â”€â”€ Fine-tune panel after scheme selection â”€â”€ */
        .finetune-panel {
            background: rgba(0, 122, 255, 0.04);
            border: 1.5px solid rgba(0, 122, 255, 0.18);
            border-radius: 12px;
            padding: 10px 12px 12px;
            margin-top: 10px;
        }

        .finetune-color-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .finetune-color-label {
            font-size: 11px;
            font-weight: 600;
            color: #1d1d1f;
            min-width: 54px;
            flex-shrink: 0;
        }

        .finetune-hex-badge {
            font-size: 10px;
            font-family: monospace;
            color: #86868b;
            background: rgba(0, 0, 0, 0.04);
            border-radius: 5px;
            padding: 2px 6px;
            min-width: 64px;
            text-align: center;
            letter-spacing: 0.03em;
        }

        /* â”€â”€ History section â”€â”€ */
        .history-details summary {
            font-size: 10px;
            font-weight: 600;
            color: #86868b;
            cursor: pointer;
            user-select: none;
            padding: 6px 2px;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .history-details summary::-webkit-details-marker {
            display: none;
        }

        .history-details summary::before {
            content: 'â–¶';
            font-size: 8px;
            transition: transform 0.2s;
            display: inline-block;
        }

        .history-details[open] summary::before {
            transform: rotate(90deg);
        }

        .history-row {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 6px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.015);
            margin-bottom: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .history-row:hover {
            background: rgba(0, 122, 255, 0.06);
        }

        .history-row-strip {
            display: flex;
            gap: 2px;
            flex: 1;
        }

        .history-row-strip span {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            display: block;
            flex-shrink: 0;
        }

        .history-row-name {
            font-size: 9px;
            color: #86868b;
            font-weight: 600;
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* â”€â”€ Drag-to-swap in fine-tune â”€â”€ */
        .ft-drag-handle {
            cursor: grab;
            font-size: 12px;
            color: #c7c7cc;
            padding: 2px;
            flex-shrink: 0;
            user-select: none;
            transition: color 0.15s;
        }

        .ft-drag-handle:hover {
            color: #007aff;
            cursor: grab;
        }

        .finetune-color-row[draggable="true"] {
            cursor: default;
            transition: background 0.15s, outline 0.15s;
        }

        .finetune-color-row.drag-over {
            background: rgba(0, 122, 255, 0.07);
            border-radius: 8px;
            outline: 1.5px dashed rgba(0, 122, 255, 0.4);
        }

        .finetune-color-row.dragging {
            opacity: 0.4;
        }
    </style>
</head>

<body class="h-screen flex bg-apple-bg text-apple-text font-sans overflow-hidden">

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LEFT SIDEBAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <aside id="sidebar"
        class="glass-panel w-[340px] min-w-[300px] flex flex-col border-r border-apple-border z-50 shadow-sm">

        <!-- Header -->
        <div class="flex-shrink-0 px-5 pt-5 pb-4 border-b border-apple-border bg-white/90 fade-up">
            <div class="flex items-center justify-between mb-1">
                <h1 class="text-xl font-bold tracking-tight">
                    çŸ©å½¢å›¾ç‰‡ <span class="text-apple-blue">ç”Ÿæˆå™¨</span>
                </h1>
                <span
                    class="text-[10px] font-semibold text-apple-tertiary bg-black/[0.04] px-2.5 py-1 rounded-full tracking-wide">V1.0</span>
            </div>
            <p class="text-xs text-apple-secondary">ç²˜è´´æ•°æ® â†’ é…ç½®æ ·å¼ â†’ å®æ—¶æ¸²æŸ“ â†’ é«˜æ¸…å¯¼å‡º</p>
        </div>

        <!-- Scrollable Config Area -->
        <div class="flex-1 overflow-y-auto slim-scroll flex flex-col gap-2 p-3">

            <!-- â”€â”€ Data Input â”€â”€ -->
            <section class="bg-white rounded-xl border border-apple-border shadow-xs p-4 fade-up"
                style="animation-delay:0.05s">
                <h2 class="text-[11px] font-semibold text-apple-tertiary uppercase tracking-wider mb-2">æ•°æ®è¾“å…¥</h2>
                <textarea id="data-input" rows="8" spellcheck="false"
                    class="w-full rounded-lg border border-black/10 bg-black/[0.02] p-3 text-[13px] font-mono leading-relaxed resize-none
                           focus:outline-none focus:ring-2 focus:ring-apple-blue/30 focus:border-apple-blue transition-all"
                    placeholder="ç²˜è´´ CSV/TSV/ç©ºæ ¼åˆ†éš”æ•°æ®ï¼Œä¾‹å¦‚ï¼š&#10;å§“å|å¹´é¾„|åŸå¸‚|å¾—åˆ†&#10;å¼ ä¸‰|28|åŒ—äº¬|95&#10;æå››|32|ä¸Šæµ·|88&#10;ç‹äº”|25|å¹¿å·|92">å§“å|å¹´é¾„|åŸå¸‚|å¾—åˆ†
å¼ ä¸‰|28|åŒ—äº¬|95
æå››|32|ä¸Šæµ·|88
ç‹äº”|25|å¹¿å·|92
èµµå…­|36|æ·±åœ³|78
å­™ä¸ƒ|29|æ­å·|91
å‘¨å…«|41|æˆéƒ½|85</textarea>
                <div class="flex gap-2 mt-2">
                    <button onclick="App.render(true)"
                        class="btn-spring flex-1 bg-gradient-to-b from-[#0a84ff] to-apple-blue text-white text-[13px] font-semibold py-2.5 rounded-full shadow-md shadow-apple-blue/20">
                        â–¶ æ¸²æŸ“è¡¨æ ¼
                    </button>
                    <button onclick="App.clearData()"
                        class="btn-spring px-4 py-2.5 rounded-full text-[13px] font-medium bg-black/[0.04] border border-black/[0.06] text-apple-text hover:bg-black/[0.08]">
                        æ¸…ç©º
                    </button>
                </div>
                <p id="parse-status" class="text-[11px] text-apple-tertiary mt-2 min-h-[16px]"></p>
            </section>

            <!-- â”€â”€ DeepSeek AI Integration â”€â”€ -->
            <section class="bg-white rounded-xl border border-apple-border shadow-xs p-4 fade-up"
                style="animation-delay:0.1s">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-[11px] font-semibold text-apple-tertiary uppercase tracking-wider">ğŸ¤– AI æ™ºèƒ½è§£æ
                    </h2>
                    <span id="ai-api-status" class="text-[10px] font-semibold px-2 py-0.5 rounded-full"></span>
                </div>

                <!-- Model Selector -->
                <div class="mb-3">
                    <label class="text-[12px] font-medium text-apple-secondary mb-1.5 block">æ¨¡å‹</label>
                    <select id="ai-model"
                        class="w-full px-3 py-2 rounded-lg border border-black/10 bg-white text-[13px] cursor-pointer focus:outline-none focus:ring-2 focus:ring-apple-blue/20 transition-all appearance-none"
                        style="background-image:url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='none' viewBox='0 0 10 10'%3E%3Cpath d='M2 3.5L5 6.5L8 3.5' stroke='%23aeaeb2' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E&quot;);background-repeat:no-repeat;background-position:right 12px center;padding-right:32px;">
                        <option value="deepseek-chat" selected>deepseek-chat</option>
                        <option value="deepseek-reasoner">deepseek-reasoner</option>
                    </select>
                </div>

                <!-- Buttons -->
                <div class="flex gap-2 mb-2">
                    <button id="ai-parse-btn" onclick="App.aiParse()"
                        class="btn-spring flex-1 bg-gradient-to-b from-purple-500 to-purple-600 text-white text-[12px] font-semibold py-2 rounded-full shadow-md shadow-purple-500/20">
                        âœ¨ AI è§£ææ•°æ®
                    </button>
                    <button onclick="App.testApi()"
                        class="btn-spring px-3 py-2 rounded-full text-[12px] font-medium bg-black/[0.04] border border-black/[0.06] text-apple-text hover:bg-black/[0.08]">
                        ğŸ”Œ æµ‹è¯•
                    </button>
                </div>
                <p id="ai-status" class="text-[10px] text-apple-tertiary mt-1 text-center min-h-[14px]"></p>

                <!-- Collapsible API Key Editor -->
                <details class="mt-2">
                    <summary
                        class="text-[10px] text-apple-tertiary cursor-pointer hover:text-apple-blue transition-colors">
                        âš™ï¸ ä¿®æ”¹ API Key</summary>
                    <input type="password" id="ai-apikey" placeholder="sk-xxxxxxxxxxxxxxxx"
                        class="w-full mt-2 px-3 py-2 rounded-lg border border-black/10 bg-black/[0.02] text-[12px] font-mono
                               focus:outline-none focus:ring-2 focus:ring-apple-blue/20 focus:border-apple-blue transition-all" onchange="App.saveApiKey()">
                </details>
            </section>

            <!-- â”€â”€ Style Config â”€â”€ -->
            <section class="bg-white rounded-xl border border-apple-border shadow-xs p-4 fade-up"
                style="animation-delay:0.15s">
                <h2 class="text-[11px] font-semibold text-apple-tertiary uppercase tracking-wider mb-3">æ ·å¼é…ç½®</h2>



                <!-- Font Family (searchable, like table.html) -->
                <div class="mb-4" style="position:relative; z-index:50;">
                    <label class="text-[12px] font-medium text-apple-secondary mb-1.5 block">å­—ä½“é¢æ¿</label>
                    <div style="display:flex; gap:6px; position:relative;">
                        <div style="flex:1; position:relative;">
                            <input type="text" id="font-family-input"
                                class="w-full px-3 py-2 rounded-lg border border-black/10 bg-white text-[13px] focus:outline-none focus:ring-2 focus:ring-apple-blue/20 transition-all"
                                placeholder="æœç´¢æˆ–è¾“å…¥å­—ä½“" value="sans-serif" autocomplete="off">
                            <ul id="font-dropdown-list" class="font-dropdown-list">
                                <li class="font-dropdown-item" data-val="sans-serif">ç³»ç»Ÿé»˜è®¤ (sans-serif)</li>
                            </ul>
                        </div>
                        <button id="font-load-btn"
                            class="btn-spring px-2.5 py-2 rounded-lg text-[13px] bg-black/[0.04] border border-black/[0.06] hover:bg-black/[0.08]"
                            title="åŠ è½½æœ¬åœ°ç³»ç»Ÿå­—ä½“">ğŸ”„</button>
                    </div>
                    <div class="flex gap-2 mt-2">
                        <select id="font-style-select"
                            class="flex-1 px-2 py-1.5 rounded-lg border border-black/10 bg-white text-[12px] cursor-pointer focus:outline-none transition-all appearance-none"
                            style="background-image:url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='none' viewBox='0 0 10 10'%3E%3Cpath d='M2 3.5L5 6.5L8 3.5' stroke='%23aeaeb2' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E&quot;);background-repeat:no-repeat;background-position:right 8px center;padding-right:24px;">
                            <option value="Regular">Regular</option>
                        </select>
                        <div class="flex items-center gap-1.5">
                            <span id="font-scale-val"
                                class="text-[11px] font-semibold text-apple-blue tabular-nums min-w-[32px] text-right">100%</span>
                            <input type="range" id="font-scale" min="0.5" max="3.0" step="0.1" value="1.0"
                                title="æ–‡å­—ç¼©æ”¾æ¯”ä¾‹" class="w-20">
                        </div>
                    </div>
                </div>



                <!-- Row Height -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-1.5">
                        <label class="text-[12px] font-medium text-apple-secondary">è¡Œé«˜</label>
                        <span id="cfg-rowheight-val"
                            class="text-[11px] font-semibold text-apple-blue tabular-nums">48</span>
                    </div>
                    <input type="range" id="cfg-rowheight" min="30" max="80" step="2" value="48"
                        oninput="document.getElementById('cfg-rowheight-val').textContent=this.value; App.render(false)"
                        class="w-full">
                </div>

                <!-- Header Font Size -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-1.5">
                        <label class="text-[12px] font-medium text-apple-secondary">è¡¨å¤´å­—å·</label>
                        <span id="cfg-hfontsize-val"
                            class="text-[11px] font-semibold text-apple-blue tabular-nums">16</span>
                    </div>
                    <input type="range" id="cfg-hfontsize" min="10" max="30" step="1" value="16"
                        oninput="document.getElementById('cfg-hfontsize-val').textContent=this.value; App.render(true)"
                        class="w-full">
                </div>

                <!-- Body Font Size -->
                <div class="mb-2">
                    <div class="flex justify-between items-center mb-1.5">
                        <label class="text-[12px] font-medium text-apple-secondary">å†…å®¹å­—å·</label>
                        <span id="cfg-bfontsize-val"
                            class="text-[11px] font-semibold text-apple-blue tabular-nums">14</span>
                    </div>
                    <input type="range" id="cfg-bfontsize" min="10" max="26" step="1" value="14"
                        oninput="document.getElementById('cfg-bfontsize-val').textContent=this.value; App.render(true)"
                        class="w-full">
                </div>
            </section>


            <!-- â”€â”€ ğŸ¨ é¢œè‰²é…ç½® (æ•´åˆåŒºå—) â”€â”€ -->
            <section class="bg-white rounded-xl border border-apple-border shadow-xs p-4 fade-up"
                style="animation-delay:0.17s">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-[11px] font-semibold text-apple-tertiary uppercase tracking-wider">ğŸ¨ é¢œè‰²é…ç½®</h2>
                    <span id="color-extract-status" class="text-[10px] text-apple-tertiary min-h-[14px]"></span>
                </div>

                <!-- ä¸»è‰²è°ƒ + èƒŒæ™¯é¢œè‰² å¹¶æ’ -->
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div
                        class="flex flex-col items-center gap-1 p-2 rounded-xl bg-black/[0.02] border border-black/[0.04]">
                        <span class="text-[10px] text-apple-secondary font-medium">è¡¨å¤´ä¸»è‰²</span>
                        <input type="color" id="cfg-color" value="#007AFF" onchange="App.render(false)">
                    </div>
                    <div class="flex flex-col items-center gap-1 p-2 rounded-xl bg-black/[0.02] border border-black/[0.04]"
                        id="bg-color-row">
                        <span class="text-[10px] text-apple-secondary font-medium">èƒŒæ™¯é¢œè‰²</span>
                        <div class="flex items-center gap-1.5">
                            <input type="color" id="cfg-bg-color" value="#FFFFFF" onchange="App.render(false)"
                                title="ç‚¹å‡»ä¿®æ”¹èƒŒæ™¯é¢œè‰²">
                            <button onclick="document.getElementById('cfg-bg-color').value='#FFFFFF'; App.render(false)"
                                class="text-[9px] px-1.5 py-0.5 rounded bg-black/[0.04] hover:bg-black/[0.08] text-apple-tertiary">é‡ç½®</button>
                        </div>
                    </div>
                </div>

                <!-- é€æ˜èƒŒæ™¯ toggle -->
                <div class="flex items-center justify-between mb-3 px-1">
                    <label class="text-[13px] font-medium">é€æ˜èƒŒæ™¯</label>
                    <label class="ios-toggle">
                        <input type="checkbox" id="cfg-transparent" onchange="App.onTransparentChange()">
                        <span class="slider"></span>
                    </label>
                </div>

                <!-- åˆ†å‰²çº¿ -->
                <div style="height:1px; background:rgba(0,0,0,0.06); margin:8px 0 12px;"></div>

                <!-- Upload area -->
                <div class="img-upload-area" id="img-upload-area" title="ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡">
                    <input type="file" accept="image/*" id="color-img-input">
                    <div id="img-upload-hint">
                        <div style="font-size:20px; margin-bottom:3px;">ğŸ–¼ï¸</div>
                        <div class="text-[12px] font-medium text-apple-blue">ä¸Šä¼ å›¾ç‰‡æå–é…è‰²</div>
                        <div class="text-[10px] text-apple-tertiary mt-1">ç‚¹å‡»æˆ–æ‹–æ‹½å›¾ç‰‡ â€” è‡ªåŠ¨åº”ç”¨åˆ°å›¾è¡¨</div>
                    </div>
                    <img id="color-img-preview" alt="é¢„è§ˆ">
                </div>

                <!-- Color swatches & scheme selection -->
                <div id="color-swatches-wrap" style="display:none; margin-top:10px;">

                    <!-- é‡æå–æŒ‰éˆ• -->
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-[11px] font-medium text-apple-secondary">é…è‰²æ–¹æ¡ˆé€‰æ‹©</span>
                        <button onclick="App.reExtractColors()"
                            class="btn-spring text-[10px] px-2 py-0.5 rounded bg-black/[0.04] hover:bg-black/[0.08] text-apple-secondary">ğŸ”„
                            é‡æå–</button>
                    </div>

                    <!-- åŸå§‹æå–æ–¹æ¡ˆ 1 -->
                    <div class="scheme-card" id="raw-scheme-card">
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <span style="font-size:10px;font-weight:600;color:#1d1d1f;">ğŸ“Š åŸå§‹æ–¹æ¡ˆä¸€</span>
                            <span style="font-size:9px;color:#86868b;">é¥±å’Œè‰²ä¸ºä¸»</span>
                        </div>
                        <div class="scheme-strip" id="raw-scheme-strip"></div>
                        <div style="font-size:9px;color:#86868b;margin-bottom:6px;" id="raw-scheme-roles"></div>
                        <button class="scheme-apply-btn outline" onclick="App.applyScheme('raw')">âœ” ä½¿ç”¨æ­¤æ–¹æ¡ˆ</button>
                    </div>

                    <!-- åŸå§‹æå–æ–¹æ¡ˆ 2 -->
                    <div class="scheme-card" id="raw-scheme-card2" style="margin-top:8px;">
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <span style="font-size:10px;font-weight:600;color:#1d1d1f;">ğŸ“Š åŸå§‹æ–¹æ¡ˆäºŒ</span>
                            <span style="font-size:9px;color:#86868b;">äº®è‰²ä¸ºä¸»</span>
                        </div>
                        <div class="scheme-strip" id="raw-scheme-strip2"></div>
                        <div style="font-size:9px;color:#86868b;margin-bottom:6px;" id="raw-scheme-roles2"></div>
                        <button class="scheme-apply-btn outline" onclick="App.applyScheme('raw2')">âœ” ä½¿ç”¨æ­¤æ–¹æ¡ˆ</button>
                    </div>

                    <!-- AI æ¨èé…è‰²æ–¹æ¡ˆ (3å¥—å¾®è°ƒ) -->
                    <div style="margin-top:12px;">
                        <div style="display:flex;align-items:center;gap:5px;margin-bottom:4px;">
                            <span style="font-size:10px;font-weight:600;color:#1d1d1f;">ğŸ¤– DeepSeek å¾®è°ƒæ–¹æ¡ˆ</span>
                            <span id="ai-scheme-badge" style="font-size:9px;color:#86868b;"></span>
                        </div>
                        <div id="ai-schemes-loading"
                            style="display:none;padding:14px;text-align:center;font-size:11px;color:#86868b;">
                            <div style="margin-bottom:4px;">&#x1F504; AI æ­£åœ¨ç”Ÿæˆå¾®è°ƒæ–¹æ¡ˆâ€¦</div>
                        </div>
                        <div id="ai-schemes-list"></div>
                    </div>

                    <!-- éšè—çš„æ‹¾è‰²å™¨ -->
                    <input type="color" id="swatch-color-picker"
                        style="position:absolute;opacity:0;pointer-events:none;width:0;height:0;">

                    <!-- å·²åº”ç”¨é…è‰²è§’è‰²è¡¨ -->
                    <div id="color-map-result"
                        style="display:none;margin-top:10px;padding:10px;background:rgba(0,0,0,0.03);border-radius:10px;border:1px solid rgba(0,0,0,0.06);">
                    </div>

                    <!-- â”€â”€ é€‰æ–¹æ¡ˆåå¾®è°ƒé¢æ¿ â”€â”€ -->
                    <div id="scheme-finetune-panel" class="finetune-panel" style="display:none;">
                        <div style="font-size:10px;font-weight:700;color:#007aff;margin-bottom:2px;">ğŸ¨ å·²é€‰æ–¹æ¡ˆ Â· å¾®è°ƒé¢œè‰²
                        </div>
                        <div style="font-size:9px;color:#86868b;margin-bottom:8px;">æ‹–åŠ¨ â‹® å¯äº’æ¢é¢œè‰²ä½ç½® Â· ä¿®æ”¹åå®æ—¶æ›´æ–°</div>

                        <!-- è¡¨å¤´èƒŒæ™¯ -->
                        <div class="finetune-color-row" data-ft-key="ft-header-color" draggable="true">
                            <span class="ft-drag-handle" title="æ‹–æ‹½äº’æ¢é¢œè‰²">â‹®</span>
                            <span class="finetune-color-label">è¡¨å¤´èƒŒæ™¯</span>
                            <input type="color" id="ft-header-color" oninput="App._onFinetuneChange()"
                                style="width:28px;height:28px;border-radius:6px;cursor:pointer;border:none;padding:0;box-shadow:0 0 0 2px rgba(0,0,0,0.08);flex-shrink:0;">
                            <span class="finetune-hex-badge" id="ft-header-hex">#000000</span>
                        </div>
                        <!-- è¡¨å¤´æ–‡å­— -->
                        <div class="finetune-color-row" data-ft-key="ft-header-text" draggable="true">
                            <span class="ft-drag-handle" title="æ‹–æ‹½äº’æ¢é¢œè‰²">â‹®</span>
                            <span class="finetune-color-label">è¡¨å¤´æ–‡å­—</span>
                            <input type="color" id="ft-header-text" oninput="App._onFinetuneChange()"
                                style="width:28px;height:28px;border-radius:6px;cursor:pointer;border:none;padding:0;box-shadow:0 0 0 2px rgba(0,0,0,0.08);flex-shrink:0;">
                            <span class="finetune-hex-badge" id="ft-header-text-hex">#ffffff</span>
                        </div>
                        <!-- å†…å®¹æ–‡å­— -->
                        <div class="finetune-color-row" data-ft-key="ft-body-text" draggable="true">
                            <span class="ft-drag-handle" title="æ‹–æ‹½äº’æ¢é¢œè‰²">â‹®</span>
                            <span class="finetune-color-label">å†…å®¹æ–‡å­—</span>
                            <input type="color" id="ft-body-text" oninput="App._onFinetuneChange()"
                                style="width:28px;height:28px;border-radius:6px;cursor:pointer;border:none;padding:0;box-shadow:0 0 0 2px rgba(0,0,0,0.08);flex-shrink:0;">
                            <span class="finetune-hex-badge" id="ft-body-text-hex">#1d1d1f</span>
                        </div>
                        <!-- å¥‡æ•°è¡Œåº•: é¢œè‰²å¯é€‰ + é€æ˜åº¦æ··åˆ -->
                        <div class="finetune-color-row" data-ft-key="ft-odd-row" draggable="true">
                            <span class="ft-drag-handle" title="æ‹–æ‹½äº’æ¢é¢œè‰²">â‹®</span>
                            <span class="finetune-color-label">å¥‡æ•°è¡Œåº•</span>
                            <input type="color" id="ft-odd-row" oninput="App._onFinetuneChange()"
                                style="width:28px;height:28px;border-radius:6px;cursor:pointer;border:none;padding:0;box-shadow:0 0 0 2px rgba(0,0,0,0.08);flex-shrink:0;">
                            <span class="finetune-hex-badge" id="ft-odd-row-hex">#e8eaf6</span>
                        </div>
                        <!-- å¥‡æ•°è¡Œåº•é€æ˜åº¦ -->
                        <div style="display:flex;align-items:center;gap:8px;padding:0 4px 4px 28px;">
                            <span style="font-size:9px;color:#86868b;min-width:28px;">é€æ˜åº¦</span>
                            <input type="range" id="ft-odd-opacity" min="0" max="90" value="60"
                                oninput="App._onFinetuneChange()" style="flex:1;">
                            <span id="ft-odd-opacity-val"
                                style="font-size:10px;font-weight:600;color:#007aff;min-width:28px;text-align:right;">60%</span>
                        </div>
                        <!-- è¾¹æ¡†é¢œè‰² -->
                        <div class="finetune-color-row" data-ft-key="ft-border" draggable="true">
                            <span class="ft-drag-handle" title="æ‹–æ‹½äº’æ¢é¢œè‰²">â‹®</span>
                            <span class="finetune-color-label">è¾¹æ¡†é¢œè‰²</span>
                            <input type="color" id="ft-border" oninput="App._onFinetuneChange()"
                                style="width:28px;height:28px;border-radius:6px;cursor:pointer;border:none;padding:0;box-shadow:0 0 0 2px rgba(0,0,0,0.08);flex-shrink:0;">
                            <span class="finetune-hex-badge" id="ft-border-hex">#e5e5ea</span>
                        </div>
                        <!-- ç”»å¸ƒèƒŒæ™¯ -->
                        <div class="finetune-color-row" data-ft-key="ft-bg-color" draggable="true">
                            <span class="ft-drag-handle" title="æ‹–æ‹½äº’æ¢é¢œè‰²">â‹®</span>
                            <span class="finetune-color-label">ç”»å¸ƒèƒŒæ™¯</span>
                            <input type="color" id="ft-bg-color" oninput="App._onFinetuneChange()"
                                style="width:28px;height:28px;border-radius:6px;cursor:pointer;border:none;padding:0;box-shadow:0 0 0 2px rgba(0,0,0,0.08);flex-shrink:0;">
                            <span class="finetune-hex-badge" id="ft-bg-hex">#ffffff</span>
                        </div>
                    </div>

                    <!-- â”€â”€ å†å²é…è‰²æ–¹æ¡ˆï¼ˆå¯æŠ˜å ï¼‰â”€â”€ -->
                    <details id="color-history-details" class="history-details" style="margin-top:10px;display:none;">
                        <summary>ğŸ•˜ å†å²é…è‰²æ–¹æ¡ˆ <span id="history-count" style="margin-left:2px;"></span></summary>
                        <div id="color-history-list" style="margin-top:4px;"></div>
                    </details>
                </div>

                <!-- Canvas (hidden, for processing) -->
                <canvas id="color-extract-canvas" style="display:none;"></canvas>
            </section>

            <!-- â”€â”€ Background & Export â”€â”€ -->
            <section class="bg-white rounded-xl border border-apple-border shadow-xs p-4 fade-up"
                style="animation-delay:0.2s">
                <h2 class="text-[11px] font-semibold text-apple-tertiary uppercase tracking-wider mb-3">èƒŒæ™¯ä¸å¯¼å‡º</h2>

                <!-- Hidden margin inputs (always 0 via auto-fit) -->
                <input type="range" id="cfg-mt" value="0" style="display:none;">
                <input type="range" id="cfg-mb" value="0" style="display:none;">
                <input type="range" id="cfg-ml" value="0" style="display:none;">
                <input type="range" id="cfg-mr" value="0" style="display:none;">

                <!-- Border Radius -->
                <div class="mb-4 mt-2">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[12px] font-medium text-apple-secondary">è¡¨æ ¼åœ†è§’</span>
                        <span id="cfg-radius-val" class="text-[10px] text-apple-blue font-mono">8</span>
                    </div>
                    <input type="range" id="cfg-radius" min="0" max="60" step="2" value="8"
                        oninput="document.getElementById('cfg-radius-val').textContent=this.value; App.render(false)"
                        class="w-full">
                </div>

                <!-- â”€â”€ JS ä»£ç æ³¨å…¥åŒº â”€â”€ -->
                <div class="mb-4 mt-2">
                    <div class="flex items-center justify-between mb-1.5 flex-wrap gap-2">
                        <label class="text-[12px] font-medium text-apple-secondary">JS é«˜çº§å®šåˆ¶ (option)</label>
                        <div class="flex gap-2 flex-wrap">
                            <button onclick="App.showGeneratedCode()"
                                class="btn-spring px-2 py-1 bg-purple-50 text-purple-600 rounded text-[10px] font-semibold hover:bg-purple-100">ğŸ‘
                                æ˜¾ç¤ºä»£ç </button>
                            <button onclick="App.runCode(false)"
                                class="btn-spring px-2 py-1 bg-apple-blue/10 text-apple-blue rounded text-[10px] font-semibold hover:bg-apple-blue/20">â–¶
                                è¿è¡Œ</button>
                            <button onclick="App.copyCode()"
                                class="btn-spring px-2 py-1 bg-black/[0.04] text-apple-text rounded text-[10px] hover:bg-black/[0.08]">ğŸ“‹
                                å¤åˆ¶</button>
                            <button onclick="App.resetCode()"
                                class="btn-spring px-2 py-1 bg-red-50 text-red-500 rounded text-[10px] hover:bg-red-100">â†º
                                é‡ç½®</button>
                        </div>
                    </div>
                    <textarea id="code-area" spellcheck="false"
                        class="w-full h-32 px-3 py-2 rounded-lg border border-black/10 bg-[#1e1e1e] text-[#d4d4d4] text-[11px] font-mono leading-relaxed focus:outline-none focus:ring-2 focus:ring-apple-blue/30 focus:border-apple-blue transition-all resize-y"
                        placeholder="// åœ¨æ­¤å¯ç”¨ JS ä¿®æ”¹ option
// ä¾‹å¦‚: option.backgroundColor = '#000';
// ä¿®æ”¹ç”Ÿæ•ˆåç‚¹å‡»è¿è¡Œã€‚"></textarea>
                    <p id="code-status" class="text-[10px] mt-1 min-h-[14px] text-apple-tertiary"></p>
                </div>

                <!-- Export Quality -->
                <div class="mb-4">
                    <label class="text-[12px] font-medium text-apple-secondary mb-1.5 block">å¯¼å‡ºè´¨é‡</label>
                    <select id="cfg-quality"
                        class="w-full px-3 py-2 rounded-lg border border-black/10 bg-white text-[13px] cursor-pointer focus:outline-none focus:ring-2 focus:ring-apple-blue/20 transition-all appearance-none"
                        style="background-image:url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='none' viewBox='0 0 10 10'%3E%3Cpath d='M2 3.5L5 6.5L8 3.5' stroke='%23aeaeb2' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E&quot;);background-repeat:no-repeat;background-position:right 12px center;padding-right:32px;">
                        <option value="4">4K é«˜æ¸… (4å€)</option>
                        <option value="8">8K è¶…æ¸… (8å€)</option>
                    </select>
                </div>

                <!-- Export Filename -->
                <div class="mb-4">
                    <label class="text-[12px] font-medium text-apple-secondary mb-1.5 block">å¯¼å‡ºæ–‡ä»¶å</label>
                    <input type="text" id="cfg-filename" value="ECharts_Table"
                        class="w-full px-3 py-2 rounded-lg border border-black/10 bg-black/[0.02] text-[13px] font-semibold text-center
                               focus:outline-none focus:ring-2 focus:ring-apple-blue/20 focus:border-apple-blue transition-all">
                </div>

                <!-- Export Buttons -->
                <button onclick="App.exportHD()"
                    class="btn-spring w-full bg-gradient-to-b from-[#30d158] to-apple-green text-white text-[13px] font-semibold py-2.5 rounded-full shadow-md shadow-apple-green/20 mb-2">
                    ğŸ“¸ æˆªå›¾å¯¼å‡º
                </button>
                <button onclick="App.exportTransparent()"
                    class="btn-spring w-full px-4 py-2.5 rounded-full text-[13px] font-medium bg-black/[0.04] border border-black/[0.06] text-apple-text hover:bg-black/[0.08] mb-2">
                    ğŸ”² å¯¼å‡ºé€æ˜èƒŒæ™¯
                </button>
                <button id="export-zip-btn" onclick="App.exportSplitZip()"
                    class="btn-spring w-full px-4 py-2.5 rounded-full text-[13px] font-medium bg-gradient-to-b from-orange-400 to-orange-500 text-white shadow-md shadow-orange-400/20">
                    ğŸ“¦ å¯¼å‡ºã€Œä»…èƒŒæ™¯ã€+ã€Œä»…æ–‡å­—ã€ZIP
                </button>
                <p id="export-status" class="text-[10px] text-apple-tertiary mt-2 text-center min-h-[14px]"></p>
            </section>

            <!-- â”€â”€ Quick Links â”€â”€ -->
            <div class="text-center py-2 fade-up" style="animation-delay:0.25s">
                <a href="Echart.html"
                    class="text-[12px] text-apple-blue font-medium hover:opacity-70 transition-opacity">â† è¿”å› ECharts
                    Studio</a>
                <span class="text-apple-tertiary mx-2">|</span>
                <a href="table.html"
                    class="text-[12px] text-apple-blue font-medium hover:opacity-70 transition-opacity">è¡¨æ ¼å¯¼å‡ºå·¥å…· â†’</a>
            </div>
        </div>
    </aside>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RIGHT PREVIEW â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <main id="preview-stage"
        class="flex-1 relative flex justify-center items-center overflow-hidden preview-grid bg-[#ececf0]"
        style="background: radial-gradient(ellipse at 30% 20%, rgba(0,122,255,0.03) 0%, transparent 60%), radial-gradient(ellipse at 70% 80%, rgba(175,82,222,0.03) 0%, transparent 60%), #ececf0;">

        <!-- Chart Container -->
        <div id="chart-container" class="bg-white rounded-2xl shadow-xl"
            style="width:1080px; height:1890px; transform-origin:center center;"></div>

        <!-- Zoom Toolbar -->
        <div
            class="zoom-bar absolute bottom-5 left-1/2 -translate-x-1/2 rounded-full px-3 py-1.5 flex items-center gap-1 shadow-lg z-50">
            <button onclick="App.zoom(-0.05)"
                class="btn-spring w-8 h-8 flex items-center justify-center rounded-lg text-base font-medium hover:bg-black/[0.06]">âˆ’</button>
            <span id="zoom-level"
                class="text-[12px] font-semibold text-apple-secondary tabular-nums min-w-[40px] text-center">45%</span>
            <button onclick="App.zoom(0.05)"
                class="btn-spring w-8 h-8 flex items-center justify-center rounded-lg text-base font-medium hover:bg-black/[0.06]">+</button>
            <div class="w-px h-4 bg-black/10 mx-1"></div>
            <button onclick="App.autoFit()"
                class="btn-spring px-2.5 h-8 flex items-center justify-center rounded-lg text-[12px] font-semibold hover:bg-black/[0.06]">Fit</button>
            <button onclick="App.resetZoom()"
                class="btn-spring px-2.5 h-8 flex items-center justify-center rounded-lg text-[12px] font-semibold hover:bg-black/[0.06]">1:1</button>
        </div>
    </main>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• JAVASCRIPT ENGINE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
        window.App = {
            chart: null,
            fontFamily: 'sans-serif',
            fontScale: 1.0,
            availableFonts: [],
            state: { width: 1080, height: 1890, viewScale: 0.45, viewX: 0, viewY: 0 },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  INIT
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            init() {
                const dom = document.getElementById('chart-container');
                this.chart = echarts.init(dom, null, { renderer: 'canvas', devicePixelRatio: 2 });
                this.initCanvasControl();
                this.applyCanvasSize();

                // Default API key â€” restore from session or use built-in
                const DEFAULT_KEY = 'sk-179eca9ce45b4bbda0537e00b1f78eca';
                const savedKey = sessionStorage.getItem('deepseek_api_key');
                const apiKeyEl = document.getElementById('ai-apikey');
                if (apiKeyEl) apiKeyEl.value = savedKey || DEFAULT_KEY;

                // Auto-test API on load
                this.testApi();

                // Init image color picker
                this.initColorPicker();

                // Restore JS Code from LocalStorage 
                if (typeof localStorage !== 'undefined') {
                    const savedCode = localStorage.getItem('echarts_studio_table_code');
                    if (savedCode) {
                        const codeEl = document.getElementById('code-area');
                        if (codeEl) codeEl.value = savedCode;
                    }
                }

                // Init font panel (searchable dropdown like table.html)
                this.initFontPanel();

                // Ctrl+Enter shortcut
                window.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'Enter') this.render(true);
                });

                // Initial render
                this.render(true);
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  DATA PARSING â€” auto-detect CSV / TSV / space
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            parseInputData(raw) {
                if (!raw || !raw.trim()) return null;
                const lines = raw.trim().split('\n').map(l => l.trim()).filter(l => l);
                if (lines.length < 2) return null; // need at least header + 1 row

                // Detect delimiter: tab > comma > multiple-spaces
                const firstLine = lines[0];
                let delimiter;
                if (firstLine.includes('\t')) delimiter = '\t';
                else if (firstLine.includes(',')) delimiter = ',';
                else if (firstLine.includes('|')) delimiter = '|';
                else delimiter = /\s{2,}/; // multiple spaces

                const splitLine = (line) => {
                    if (delimiter instanceof RegExp) return line.split(delimiter).map(s => s.trim());
                    if (delimiter === ',') {
                        const result = [];
                        let current = '';
                        let inQuotes = false;
                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            if (char === '"' && line[i + 1] === '"') {
                                current += '"';
                                i++; // skip escaped quote
                            } else if (char === '"') {
                                inQuotes = !inQuotes;
                            } else if (char === ',' && !inQuotes) {
                                result.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        result.push(current.trim());
                        // Remove outer quotes if they exist exactly once around the value
                        return result.map(s => {
                            if (s.startsWith('"') && s.endsWith('"') && s.length >= 2) {
                                return s.slice(1, -1).trim();
                            }
                            return s;
                        });
                    }
                    return line.split(delimiter).map(s => s.trim());
                };

                const headers = splitLine(lines[0]);
                const rows = [];
                for (let i = 1; i < lines.length; i++) {
                    const cells = splitLine(lines[i]);
                    // Pad or trim to match header count
                    while (cells.length < headers.length) cells.push('');
                    rows.push(cells.slice(0, headers.length));
                }

                return { headers, rows };
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  API KEY â€” save / test
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            saveApiKey() {
                const key = document.getElementById('ai-apikey').value.trim();
                if (key) sessionStorage.setItem('deepseek_api_key', key);
                this.testApi();
            },

            async testApi() {
                const apiKey = (document.getElementById('ai-apikey')?.value || '').trim();
                const statusBadge = document.getElementById('ai-api-status');
                const statusEl = document.getElementById('ai-status');

                if (!apiKey) {
                    if (statusBadge) { statusBadge.textContent = 'âŒ æ—  Key'; statusBadge.style.cssText = 'color:#ff3b30;background:rgba(255,59,48,0.08);'; }
                    if (statusEl) { statusEl.textContent = 'âŒ è¯·å¡«å†™ API Key'; statusEl.style.color = '#ff3b30'; }
                    return;
                }
                if (statusBadge) { statusBadge.textContent = 'â³ æµ‹è¯•ä¸­'; statusBadge.style.cssText = 'color:#86868b;background:rgba(0,0,0,0.04);'; }
                if (statusEl) { statusEl.textContent = 'æ­£åœ¨éªŒè¯ API Key...'; statusEl.style.color = '#86868b'; }

                try {
                    const res = await fetch('https://api.deepseek.com/chat/completions', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey },
                        body: JSON.stringify({ model: 'deepseek-chat', messages: [{ role: 'user', content: 'hi' }], max_tokens: 1 })
                    });
                    const data = await res.json();
                    if (data.choices || data.id) {
                        if (statusBadge) { statusBadge.textContent = 'âœ… å¯ç”¨'; statusBadge.style.cssText = 'color:#34c759;background:rgba(52,199,89,0.08);'; }
                        if (statusEl) { statusEl.textContent = 'âœ… API è¿æ¥æ­£å¸¸'; statusEl.style.color = '#34c759'; }
                    } else {
                        throw new Error(data.error?.message || 'æœªçŸ¥é”™è¯¯');
                    }
                } catch (e) {
                    if (statusBadge) { statusBadge.textContent = 'âŒ ä¸å¯ç”¨'; statusBadge.style.cssText = 'color:#ff3b30;background:rgba(255,59,48,0.08);'; }
                    if (statusEl) { statusEl.textContent = 'âŒ ç½‘ç»œé”™è¯¯: ' + (e.message || e); statusEl.style.color = '#ff3b30'; }
                    console.error('API Test error:', e);
                }
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  FONT PANEL â€” searchable dropdown (like table.html)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async loadSystemFonts() {
                if (!window.queryLocalFonts) {
                    alert('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒè¯»å–ç³»ç»Ÿå­—ä½“åˆ—è¡¨ (éœ€ Chrome 103+ / Edge)ã€‚\nä½ å¯ä»¥ç›´æ¥åœ¨æ–‡æœ¬æ¡†ä¸­è¾“å…¥å­—ä½“å (ä¾‹å¦‚ "Microsoft YaHei") æ¥å¼ºåˆ¶åº”ç”¨ã€‚');
                    return;
                }
                try {
                    const fonts = await window.queryLocalFonts();
                    const familyMap = new Map();
                    fonts.forEach(f => {
                        let existing = familyMap.get(f.family);
                        if (!existing) { existing = { fullName: f.fullName, styles: [] }; familyMap.set(f.family, existing); }
                        existing.styles.push({ style: f.style || 'Regular', fullName: f.fullName, postscriptName: f.postscriptName });
                        if (/[\u4e00-\u9fa5]/.test(f.fullName) && !/[\u4e00-\u9fa5]/.test(existing.fullName)) existing.fullName = f.fullName;
                    });
                    familyMap.forEach(v => {
                        const uniq = []; const seen = new Set();
                        v.styles.forEach(s => { if (!seen.has(s.style)) { seen.add(s.style); uniq.push(s); } });
                        uniq.sort((a, b) => {
                            const w = s => { s = s.toLowerCase(); if (s.includes('thin')) return 100; if (s.includes('light')) return 300; if (s.includes('regular') || s.includes('normal')) return 400; if (s.includes('medium')) return 500; if (s.includes('semibold')) return 600; if (s.includes('bold')) return 700; if (s.includes('black') || s.includes('heavy')) return 900; return 400; };
                            return w(a.style) - w(b.style);
                        });
                        v.styles = uniq;
                    });
                    this.availableFonts = Array.from(familyMap, ([family, v]) => ({ family, displayName: v.fullName, styles: v.styles }));
                    this.availableFonts.sort((a, b) => a.displayName.localeCompare(b.displayName, 'zh-Hans'));
                } catch (e) { alert('åŠ è½½å­—ä½“å¤±è´¥: ' + e.message); }
            },

            initFontPanel() {
                const fontInput = document.getElementById('font-family-input');
                const fontList = document.getElementById('font-dropdown-list');
                const fontLoadBtn = document.getElementById('font-load-btn');
                const fontStyleSelect = document.getElementById('font-style-select');
                const fontScaleNode = document.getElementById('font-scale');
                const fontScaleVal = document.getElementById('font-scale-val');

                // Scale slider
                if (fontScaleNode) {
                    fontScaleNode.addEventListener('input', (e) => {
                        this.fontScale = parseFloat(e.target.value) || 1.0;
                        if (fontScaleVal) fontScaleVal.textContent = Math.round(this.fontScale * 100) + '%';
                        this.render(false);
                    });
                }

                // Populate font styles for a selected family
                this.populateFontStyles = (familyName) => {
                    if (!fontStyleSelect) return;
                    fontStyleSelect.innerHTML = '';
                    const fontObj = this.availableFonts.find(f => f.family === familyName);
                    if (!fontObj || !fontObj.styles || fontObj.styles.length === 0) {
                        fontStyleSelect.innerHTML = '<option value="Regular">Regular</option>';
                        fontStyleSelect.disabled = true;
                    } else {
                        fontStyleSelect.disabled = false;
                        fontObj.styles.forEach(s => { const opt = document.createElement('option'); opt.value = s.postscriptName; opt.textContent = s.style; fontStyleSelect.appendChild(opt); });
                    }
                };

                if (fontStyleSelect) fontStyleSelect.addEventListener('change', () => this.render(false));

                // Render font list items
                this.renderFonts = (filterKey = '') => {
                    if (!fontList) return;
                    let html = '<li class="font-dropdown-item" data-val="sans-serif" style="font-family:sans-serif;">ç³»ç»Ÿé»˜è®¤ (sans-serif)</li>';
                    const key = filterKey.toLowerCase().trim();
                    const filtered = key ? this.availableFonts.filter(f => f.family.toLowerCase().includes(key) || f.displayName.toLowerCase().includes(key)) : this.availableFonts;
                    filtered.forEach(f => { html += `<li class="font-dropdown-item" data-val="${f.family}" style="font-family:'${f.family}',sans-serif;" title="${f.family}">${f.displayName}</li>`; });
                    if (filtered.length === 0 && key) html += '<li class="font-dropdown-item" style="color:#86868b;pointer-events:none;">æ— åŒ¹é…å­—ä½“, æŒ‰å›è½¦å¼ºåˆ¶åº”ç”¨</li>';
                    fontList.innerHTML = html;
                };

                let hideTimeout; let previewOriginal = null;

                if (fontInput) {
                    fontInput.addEventListener('focus', () => { this.renderFonts(''); fontList && fontList.classList.add('show'); fontInput.select(); });
                    fontInput.addEventListener('click', () => fontInput.select());
                    fontInput.addEventListener('blur', () => {
                        hideTimeout = setTimeout(() => {
                            fontList && fontList.classList.remove('show');
                            if (previewOriginal !== null) { this.fontFamily = previewOriginal; previewOriginal = null; }
                            if (fontInput) { this.fontFamily = fontInput.value.trim() || 'sans-serif'; if (this.populateFontStyles) this.populateFontStyles(this.fontFamily); }
                            this.render(false);
                        }, 200);
                    });
                    fontInput.addEventListener('input', (e) => { this.renderFonts(e.target.value); fontList && fontList.classList.add('show'); });
                    fontInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { fontList && fontList.classList.remove('show'); fontInput.blur(); } });
                }

                if (fontList) {
                    fontList.addEventListener('mouseover', (e) => {
                        const item = e.target.closest('.font-dropdown-item');
                        if (item && item.dataset.val) { if (previewOriginal === null) previewOriginal = this.fontFamily; this.fontFamily = item.dataset.val; this.render(false); }
                    });
                    fontList.addEventListener('mouseleave', () => {
                        if (previewOriginal !== null) { this.fontFamily = previewOriginal; previewOriginal = null; this.render(false); }
                    });
                    fontList.addEventListener('mousedown', (e) => {
                        const item = e.target.closest('.font-dropdown-item');
                        if (item && item.dataset.val) {
                            if (fontInput) fontInput.value = item.dataset.val;
                            previewOriginal = null;
                            if (this.populateFontStyles) this.populateFontStyles(item.dataset.val);
                            this.fontFamily = item.dataset.val;
                            if (hideTimeout) clearTimeout(hideTimeout);
                            fontList.classList.remove('show');
                            this.render(false);
                        }
                    });
                }

                if (fontLoadBtn) {
                    fontLoadBtn.addEventListener('click', () => {
                        this.loadSystemFonts().then(() => {
                            if (fontInput) {
                                this.renderFonts(fontInput.value === 'sans-serif' ? '' : fontInput.value);
                                fontInput.focus();
                                fontList && fontList.classList.add('show');
                            }
                        });
                    });
                }
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  Hardened Precision Scraper â€” ç²¾å¯†é‡‘èæ•°æ®è½¬æ¢å™¨
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async aiParse() {
                const apiKey = (document.getElementById('ai-apikey')?.value || '').trim();
                const model = document.getElementById('ai-model').value;
                let rawText = document.getElementById('data-input').value.trim();
                const statusEl = document.getElementById('ai-status');
                const btn = document.getElementById('ai-parse-btn');

                if (!apiKey) { statusEl.textContent = 'âŒ è¯·å¡«å†™ API Key'; statusEl.style.color = '#ff3b30'; return; }
                if (!rawText) { statusEl.textContent = 'âŒ è¯·å…ˆç²˜è´´æ•°æ®'; statusEl.style.color = '#ff3b30'; return; }

                sessionStorage.setItem('deepseek_api_key', apiKey);

                btn.disabled = true;
                const oldText = btn.textContent;
                btn.textContent = 'â³ AI æ­£åœ¨åˆ†æ...';
                statusEl.textContent = 'æ­£åœ¨å‘èµ·ç²¾å¯†åˆ†æ (' + model + ')...';
                statusEl.style.color = '#86868b';

                // Pre-processing
                // ç§»é™¤ä»…ä½œä¸ºè§†è§‰å¹²æ‰°çš„æ— æ„ä¹‰é€—å· (ä¿ç•™åƒåˆ†ä½æ•°å­—å¦‚ 1,000)
                rawText = rawText.replace(/([^\d]),([^\d])/g, '$1 $2');
                rawText = rawText.replace(/\n\s*\n/g, '\n').trim();

                const systemPrompt = `ä½ ç°åœ¨æ˜¯ã€ç²¾å¯†é‡‘èæ•°æ®è½¬æ¢å™¨ã€‘ã€‚ä½ çš„ä»»åŠ¡æ˜¯å°†ä¹±åºæ–‡æœ¬æ•°æ®è½¬æ¢ä¸ºç»“æ„åŒ–çš„ JSONï¼Œå†…éƒ¨é€»è¾‘å¿…é¡»ä½¿ç”¨ç«–çº¿ï¼ˆ|ï¼‰ä½œä¸ºåˆ†éš”æ ‡å‡†ã€‚

æ ¸å¿ƒè§„åˆ™ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰ï¼š
1. **å¼ºåˆ¶å†…éƒ¨é€»è¾‘**ï¼šåœ¨è¿”å› JSON ä¹‹å‰ï¼Œè¯·å…ˆåœ¨å†…éƒ¨å°†æ•°æ®é€»è¾‘æ•´ç†ä¸ºä»¥ ç«–çº¿ï¼ˆ|ï¼‰ åˆ†éš”çš„æ ¼å¼ã€‚åœ¨æœ€ç»ˆç”Ÿæˆçš„ DATA æ•°ç»„ä¸­ï¼Œç¡®ä¿ 500,000 è¿™æ ·çš„æ•°å­—è¢«è§†ä¸ºä¸€ä¸ªæ•´ä½“å­—ç¬¦ä¸²ã€‚
2. **ä¸¥ç¦ä½¿ç”¨é€—å·ä½œä¸ºåˆ—åˆ†éš”ç¬¦ã€‚**
3. **æ•°å€¼ä¿æŠ¤**ï¼šæ‰€æœ‰çš„åƒåˆ†ä½é€—å·å¿…é¡»ä¿ç•™åœ¨æ•°å­—å­—ç¬¦ä¸²å†…éƒ¨ï¼ˆä¾‹å¦‚ "1,000,000"ï¼‰ï¼Œä¸å¾—æ‹†åˆ†ã€‚
4. **ç»“æ„å¯¹é½**ï¼šæ¯ä¸€è¡Œæ•°æ®å¿…é¡»ä¸¥æ ¼åŒ…å«ç›¸åº”çš„åˆ—æ•°ï¼Œç”± | é€»è¾‘åˆ’åˆ†ã€‚
5. **ç©ºå€¼è¡¥é½**ï¼šå¦‚æœæŸåˆ—æ•°æ®ç¼ºå¤±ï¼Œå¿…é¡»ä½¿ç”¨ "-" å ä½ã€‚
6. **è‡ªåŠ¨è¯†åˆ«è¡¨å¤´**ï¼šè¯·æ ¹æ®æ–‡æœ¬å†…å®¹è‡ªåŠ¨æ¨æ–­å‡ºè¡¨å¤´çš„æ•°ç»„ç»“æ„ï¼Œä¸è¦å†™æ­» 5 åˆ—ï¼Œä»¥å®é™…è¡Œæ•°æ®ä¸ºå‡†ã€‚

è¿”å›æ ¼å¼è¦æ±‚å¿…é¡»æ˜¯ä¸€æ®µçº¯ JSONï¼Œä¸è¦å¸¦ markdown ä»£ç å—æ ‡è®°ï¼Œä¸è¦åŒ…å«å…¶ä»–è¯´æ˜è¯­å¥ï¼š
{
  "headers": ["ä¿å•å¹´åº¦", "ç´¯è®¡ç¼´è´¹", "æå–é‡‘é¢", "ç´¯è®¡æå–", "è´¦æˆ·ä½™é¢"],
  "data": [
    ["1", "500,000", "-", "-", "0"],
    ["2", "1,000,000", "-", "-", "65,340"]
  ]
}`;

                try {
                    const res = await fetch('https://api.deepseek.com/chat/completions', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey },
                        body: JSON.stringify({
                            model: model,
                            messages: [
                                { role: 'system', content: systemPrompt },
                                { role: 'user', content: rawText }
                            ],
                            max_tokens: 4096,
                            temperature: 0.1
                        })
                    });

                    const responseData = await res.json();
                    if (responseData.error) {
                        statusEl.textContent = 'âŒ API é”™è¯¯: ' + (responseData.error.message || JSON.stringify(responseData.error));
                        statusEl.style.color = '#ff3b30';
                        return;
                    }

                    let rawContent = (responseData.choices?.[0]?.message?.content || '').trim();
                    if (!rawContent) { statusEl.textContent = 'âŒ AI æœªè¿”å›å†…å®¹'; statusEl.style.color = '#ff3b30'; return; }

                    let jsonContent = rawContent;
                    if (jsonContent.startsWith('```')) {
                        const lines = jsonContent.split('\n');
                        if (lines.length >= 2) {
                            if (lines[0].startsWith('```')) lines.shift();
                            if (lines[lines.length - 1].startsWith('```')) lines.pop();
                            jsonContent = lines.join('\n').trim();
                        }
                    }

                    // Robust JSON extraction
                    const jsonMatch = jsonContent.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) throw new Error('æ— æ³•æå– JSON ç»“æ„');
                    const parsed = JSON.parse(jsonMatch[0]);

                    if (!parsed.headers || !parsed.data) throw new Error('JSON å­—æ®µç¼ºå¤±(headers æˆ– data)');

                    const colsCount = parsed.headers.length;
                    const rows = parsed.data.map(row => {
                        const r = [...row];
                        while (r.length < colsCount) r.push('-');
                        return r.slice(0, colsCount);
                    });

                    // ä½¿ç”¨ "|" ä½œä¸ºåˆ†éš”ç¬¦å¼ºåˆ¶å†™å…¥è¾“å…¥æ¡†
                    const outputLines = [parsed.headers.join('|')];
                    rows.forEach(row => outputLines.push(row.join('|')));

                    document.getElementById('data-input').value = outputLines.join('\n');

                    // Immediate Update
                    this.render(true);

                    statusEl.textContent = `âœ… ç²¾å¯†è§£ææˆåŠŸ (${rows.length} è¡Œ)`;
                    statusEl.style.color = '#34c759';
                    statusEl.classList.remove('success-toast');
                    void statusEl.offsetWidth;
                    statusEl.classList.add('success-toast');

                } catch (e) {
                    console.error('AI Parse Error:', e);
                    statusEl.textContent = 'âŒ è§£æå¤±è´¥: ' + (e.message || e);
                    statusEl.style.color = '#ff3b30';
                } finally {
                    btn.disabled = false;
                    btn.textContent = oldText;
                }
            },

            async parseData(rawText) {
                // æœ¬åœ°è§£æ fallback
                return this.parseInputData(rawText);
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  GET CONFIG from UI
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            getConfig() {
                return {
                    primaryColor: document.getElementById('cfg-color').value,
                    bgColor: (document.getElementById('cfg-bg-color')?.value) || '#FFFFFF',
                    fontFamily: this.fontFamily || 'sans-serif',
                    fontScale: this.fontScale || 1.0,
                    rowHeight: parseInt(document.getElementById('cfg-rowheight').value),
                    headerFontSize: parseInt(document.getElementById('cfg-hfontsize').value),
                    bodyFontSize: parseInt(document.getElementById('cfg-bfontsize').value),
                    transparent: document.getElementById('cfg-transparent').checked,
                    marginTop: parseInt(document.getElementById('cfg-mt').value) || 0,
                    marginBottom: parseInt(document.getElementById('cfg-mb').value) || 0,
                    marginLeft: parseInt(document.getElementById('cfg-ml').value) || 0,
                    marginRight: parseInt(document.getElementById('cfg-mr').value) || 0,
                    borderRadius: parseInt(document.getElementById('cfg-radius')?.value || '8') || 0,
                };
            },

            // Called when any margin slider changes
            onMarginChange() {
                const raw = document.getElementById('data-input').value;
                const data = this.parseInputData(raw);
                if (data) this.autoFitToData(data);
                this.render(false);
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  BUILD ECHARTS OPTION â€” custom series table
            //  â˜… Core: uses type:'custom' + renderItem
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // renderMode: 'normal' | 'textOnly' | 'bgOnly'
            buildTableOption(data, config, renderMode = 'normal') {
                if (!data || !data.headers || !data.rows) return null;

                const { headers, rows } = data;
                const COLS = headers.length;
                const ROWS = rows.length;
                const TOTAL_ROWS = ROWS + 1; // +1 for header

                const ROW_H = config.rowHeight;
                const TABLE_H = TOTAL_ROWS * ROW_H;
                const canvasW = this.state.width;
                const canvasH = this.state.height;

                // Left margin is ALWAYS 0 â€” table always starts at the left edge of canvas
                // Table width fills the full canvas width (left/right margin sliders do not affect horizontal layout)
                const availableW = Math.max(COLS * 20, canvasW);

                const COL_W = availableW / COLS;
                const TABLE_W = availableW;

                // OFFSET_X is always 0: table is always anchored to the left canvas edge
                const OFFSET_X = 0;

                // Position Y based on Top Margin only
                const OFFSET_Y = config.marginTop;

                // Lighter/darker from primary for alternating rows
                const hexToRgb = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return [r, g, b];
                };
                const [pr, pg, pb] = hexToRgb(config.primaryColor);

                // palette controls row colors, but cfg-color ALWAYS controls the header
                // (so changing the primary color picker always takes effect)
                const palette = this._appliedPalette || null;
                const headerBg = config.primaryColor;  // always from cfg-color
                const headerTextColor = palette ? palette.textContrast : '#FFFFFF';
                const rowEvenBg = config.transparent ? 'transparent' : config.bgColor;
                const rowOddBg = palette ? `rgba(${hexToRgb(palette.sidebar).join(',')}, 0.06)` : `rgba(${pr}, ${pg}, ${pb}, 0.04)`;
                const borderColor = palette ? `rgba(${hexToRgb(palette.highlight).join(',')}, 0.18)` : `rgba(${pr}, ${pg}, ${pb}, 0.12)`;
                const cellTextColor = palette ? palette.textMain : '#1d1d1f';

                // Build flat data: [rowIndex, colIndex, cellValue, isHeader]
                const seriesData = [];
                // Header row (index 0)
                for (let c = 0; c < COLS; c++) {
                    seriesData.push([0, c, headers[c], 1]);
                }
                // Data rows (index 1..ROWS)
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        seriesData.push([r + 1, c, rows[r][c], 0]);
                    }
                }

                // â˜… Custom series renderItem â€” THE CORE RENDERING ENGINE
                // This draws each table cell as a group of rect + text
                const renderItem = (params, api) => {
                    const rowIdx = api.value(0);
                    const colIdx = api.value(1);
                    const cellText = api.value(2);
                    const isHeader = api.value(3);

                    const x = OFFSET_X + colIdx * COL_W;
                    const y = OFFSET_Y + rowIdx * ROW_H;

                    // Determine cell background
                    let bgColor;
                    if (isHeader) {
                        bgColor = headerBg;
                    } else {
                        bgColor = (rowIdx % 2 === 0) ? rowOddBg : rowEvenBg;
                    }

                    // Build group of children
                    const children = [];

                    // â‘  Cell background rect (skip in textOnly mode)
                    const R = config.borderRadius || 0;
                    if (renderMode !== 'textOnly') {
                        // Determine corner radii for this cell
                        let cellShape = { x, y, width: COL_W, height: ROW_H };
                        if (R > 0) {
                            if (isHeader && colIdx === 0) cellShape.r = [R, 0, 0, 0];
                            else if (isHeader && colIdx === COLS - 1) cellShape.r = [0, R, 0, 0];
                            else if (!isHeader && rowIdx === ROWS && colIdx === 0) cellShape.r = [0, 0, 0, R];
                            else if (!isHeader && rowIdx === ROWS && colIdx === COLS - 1) cellShape.r = [0, 0, R, 0];
                        }
                        children.push({
                            type: 'rect',
                            shape: cellShape,
                            style: {
                                fill: bgColor,
                                stroke: borderColor,
                                lineWidth: 0.5,
                            },
                        });
                    }

                    // â‘¡ Cell text (skip in bgOnly mode)
                    if (renderMode !== 'bgOnly') {
                        children.push({
                            type: 'text',
                            style: {
                                x: x + COL_W / 2,
                                y: y + ROW_H / 2,
                                text: String(cellText),
                                fill: isHeader ? headerTextColor : cellTextColor,
                                font: `${isHeader ? 'bold' : 'normal'} ${Math.round((isHeader ? config.headerFontSize : config.bodyFontSize) * (config.fontScale || 1))}px ${config.fontFamily}`,
                                textAlign: 'center',
                                textVerticalAlign: 'middle',
                                truncate: { outerWidth: COL_W - 12, ellipsis: 'â€¦' },
                            },
                        });
                    }

                    return {
                        type: 'group',
                        children: children,
                    };
                };

                // â˜… ECharts option using custom series
                // Background logic per render mode
                let optBg;
                if (renderMode === 'textOnly') optBg = 'transparent';
                else if (renderMode === 'bgOnly') optBg = config.transparent ? 'transparent' : config.bgColor;
                else optBg = config.transparent ? 'transparent' : config.bgColor;

                const option = {
                    backgroundColor: optBg,
                    animation: true,
                    animationDuration: 600,
                    animationEasing: 'cubicOut',
                    // No axis / grid â€” pure custom rendering
                    xAxis: { show: false, min: 0, max: this.state.width },
                    yAxis: { show: false, min: 0, max: this.state.height, inverse: true },
                    grid: { left: 0, right: 0, top: 0, bottom: 0, containLabel: false },
                    tooltip: { show: false },
                    series: [{
                        type: 'custom',
                        renderItem: renderItem,
                        data: seriesData,
                        // Each data point has 4 dimensions: [rowIdx, colIdx, text, isHeader]
                        encode: { x: 1, y: 0 },
                        coordinateSystem: 'cartesian2d',
                        z: 10,
                    }],
                    title: { show: false },
                };

                // â˜… Inject user JS logic if any directly onto option
                const codeEl = document.getElementById('code-area');
                if (codeEl && codeEl.value && codeEl.value.trim()) {
                    try {
                        const code = codeEl.value;
                        // Use a wrapper that supports BOTH:
                        //   a) mutation: option.xxx = yyy  (mutates the passed object)
                        //   b) reassignment: option = {new obj}  (return value captured)
                        const func = new Function('option', `
                            "use strict";
                            ${code}
                            return option;
                        `);
                        const returned = func(option);
                        // If the code returned a new non-null object (e.g. option = {...}), merge it in
                        if (returned !== undefined && returned !== null && typeof returned === 'object' && returned !== option) {
                            Object.assign(option, returned);
                        }
                        const statusEl = document.getElementById('code-status');
                        if (statusEl) { statusEl.textContent = 'âœ… JS è¿è¡ŒæˆåŠŸ'; statusEl.style.color = '#34c759'; setTimeout(() => { if (statusEl.textContent.includes('è¿è¡ŒæˆåŠŸ')) statusEl.textContent = ''; }, 1500); }
                    } catch (e) {
                        const statusEl = document.getElementById('code-status');
                        if (statusEl) {
                            statusEl.textContent = 'âš ï¸ è¿è¡Œå¤±è´¥: ' + (e && e.message ? e.message : String(e));
                            statusEl.style.color = '#ff3b30';
                        }
                        console.error('JS Injection Error', e);
                    }
                }

                return option;
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  RENDER â€” main reactive binding
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            render(isFullReset = false) {
                const statusEl = document.getElementById('parse-status');
                const raw = document.getElementById('data-input').value;
                const data = this.parseInputData(raw);

                if (!data) {
                    if (statusEl) { statusEl.textContent = 'âš ï¸ æ— æ³•è§£ææ•°æ®ï¼Œè¯·æ£€æŸ¥æ ¼å¼'; statusEl.style.color = '#ff3b30'; }
                    return;
                }

                if (statusEl) {
                    statusEl.textContent = `âœ… å·²è§£æ ${data.headers.length} åˆ— Ã— ${data.rows.length} è¡Œ`;
                    statusEl.style.color = '#34c759';
                }

                // Always auto-fit canvas
                this.autoFitToData(data);

                const config = this.getConfig();
                const option = this.buildTableOption(data, config);

                if (!option) return;

                // Update chart container background and border-radius
                const container = document.getElementById('chart-container');
                const radius = config.borderRadius || 0;
                container.style.background = config.transparent ? 'repeating-conic-gradient(#e0e0e0 0% 25%, #fff 0% 50%) 0 0/20px 20px' : config.bgColor;
                container.style.borderRadius = radius + 'px';
                container.style.overflow = radius > 0 ? 'hidden' : '';

                if (isFullReset) this.chart.clear();
                this.chart.setOption(option, { notMerge: isFullReset });
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  TRANSPARENT BACKGROUND TOGGLE HANDLER
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            onTransparentChange() {
                const isTransparent = document.getElementById('cfg-transparent').checked;
                const bgColorRow = document.getElementById('bg-color-row');
                if (bgColorRow) bgColorRow.style.opacity = isTransparent ? '0.4' : '1';
                this.render(false);
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  JS CODE EXTENSIONS
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            runCode(isFullReset = false) {
                const code = document.getElementById('code-area').value;
                if (typeof localStorage !== 'undefined') {
                    localStorage.setItem('echarts_studio_table_code', code);
                }
                this.render(isFullReset);
            },

            // æ˜¾ç¤ºå½“å‰å›¾è¡¨ç”Ÿæˆçš„ option ä»£ç ï¼ˆåºåˆ—åŒ–ä¸ºå¯è¯» JSï¼‰
            showGeneratedCode() {
                const raw = document.getElementById('data-input').value;
                const data = this.parseInputData(raw);
                if (!data) {
                    const st = document.getElementById('code-status');
                    if (st) { st.textContent = 'âš ï¸ æš‚æ— æ•°æ®ï¼Œè¯·å…ˆæ¸²æŸ“è¡¨æ ¼'; st.style.color = '#ff9500'; }
                    return;
                }
                const config = this.getConfig();
                // Build option WITHOUT the JS injection from code-area (to show the base option)
                const oldCodeAreaVal = document.getElementById('code-area').value;
                document.getElementById('code-area').value = '';
                const option = this.buildTableOption(data, config, 'normal');
                document.getElementById('code-area').value = oldCodeAreaVal;

                if (!option) return;

                // Serialize: renderItem function is not serializable; replace with placeholder comment
                const optCopy = Object.assign({}, option);
                if (optCopy.series) {
                    optCopy.series = optCopy.series.map(s => {
                        const sc = Object.assign({}, s);
                        if (typeof sc.renderItem === 'function') sc.renderItem = '/* renderItem function â€” generated by App */';
                        return sc;
                    });
                }

                // Pretty-print
                let jsonStr;
                try {
                    jsonStr = JSON.stringify(optCopy, (k, v) => {
                        if (typeof v === 'string' && v.startsWith('/*')) return v;
                        return v;
                    }, 2);
                    // Fix quoted placeholder
                    jsonStr = jsonStr.replace(/"(\/\* renderItem function[^"]*)"/g, '$1');
                } catch (e) {
                    jsonStr = String(option);
                }

                const code = `// å½“å‰å›¾è¡¨ optionï¼ˆç”±æé€Ÿä¸­è½¬å™¨ç”Ÿæˆï¼‰\n// æ³¨æ„: renderItem ä¸ºå‡½æ•°ï¼Œæ— æ³•å®Œæ•´åºåˆ—åŒ–\noption = ${jsonStr};`;
                document.getElementById('code-area').value = code;

                const st = document.getElementById('code-status');
                if (st) { st.textContent = 'âœ… å·²æ˜¾ç¤ºå½“å‰å›¾è¡¨ option ä»£ç '; st.style.color = '#34c759'; }
                setTimeout(() => { if (st && st.textContent.includes('å·²æ˜¾ç¤º')) st.textContent = ''; }, 2500);
            },

            copyCode() {
                const code = document.getElementById('code-area').value;
                if (!code) {
                    const st = document.getElementById('code-status');
                    if (st) { st.textContent = 'æ²¡æœ‰ä»£ç å¯å¤åˆ¶'; st.style.color = '#ff9500'; }
                    return;
                }
                navigator.clipboard.writeText(code).then(() => {
                    const st = document.getElementById('code-status');
                    if (st) { st.textContent = 'ä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼'; st.style.color = '#34c759'; }
                    setTimeout(() => { if (st && st.textContent.includes('å·²å¤åˆ¶')) st.textContent = ''; }, 2000);
                }).catch(err => {
                    const st = document.getElementById('code-status');
                    if (st) { st.textContent = 'å¤åˆ¶å¤±è´¥: ' + err; st.style.color = '#ff3b30'; }
                });
            },
            resetCode() {
                document.getElementById('code-area').value = '';
                if (typeof localStorage !== 'undefined') localStorage.removeItem('echarts_studio_table_code');
                const st = document.getElementById('code-status');
                if (st) { st.textContent = ''; }
                this.render(false);
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  CLEAR DATA
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  IMAGE COLOR EXTRACTION
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            _extractedColors: [],  // holds current 6 hex strings
            _currentSwatchIndex: -1,
            _colorImgEl: null,

            initColorPicker() {
                const input = document.getElementById('color-img-input');
                const uploadArea = document.getElementById('img-upload-area');

                if (input) {
                    input.addEventListener('change', (e) => {
                        const file = e.target.files && e.target.files[0];
                        if (file) this._loadImageFile(file);
                    });
                }

                // Drag-and-drop
                if (uploadArea) {
                    uploadArea.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        uploadArea.style.borderColor = 'rgba(0,122,255,0.8)';
                        uploadArea.style.background = 'rgba(0,122,255,0.09)';
                    });
                    uploadArea.addEventListener('dragleave', () => {
                        uploadArea.style.borderColor = '';
                        uploadArea.style.background = '';
                    });
                    uploadArea.addEventListener('drop', (e) => {
                        e.preventDefault();
                        uploadArea.style.borderColor = '';
                        uploadArea.style.background = '';
                        const file = e.dataTransfer.files && e.dataTransfer.files[0];
                        if (file && file.type.startsWith('image/')) this._loadImageFile(file);
                    });
                }

                // Swatch color picker
                const picker = document.getElementById('swatch-color-picker');
                if (picker) {
                    picker.addEventListener('input', (e) => {
                        if (this._currentSwatchIndex < 0) return;
                        const newColor = e.target.value;
                        this._extractedColors[this._currentSwatchIndex] = newColor;
                        this._renderSwatches();
                    });
                }

                // â”€â”€ Drag-to-swap in fine-tune panel â”€â”€
                // Delegated to the panel container so it works even when panel is re-shown
                const ftPanel = document.getElementById('scheme-finetune-panel');
                if (ftPanel) {
                    let dragSrcKey = null;

                    ftPanel.addEventListener('dragstart', (e) => {
                        const row = e.target.closest('[data-ft-key]');
                        if (!row) { e.preventDefault(); return; }
                        dragSrcKey = row.dataset.ftKey;
                        row.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', dragSrcKey);
                    });

                    ftPanel.addEventListener('dragend', (e) => {
                        ftPanel.querySelectorAll('.finetune-color-row').forEach(r => {
                            r.classList.remove('dragging', 'drag-over');
                        });
                        dragSrcKey = null;
                    });

                    ftPanel.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        const row = e.target.closest('[data-ft-key]');
                        ftPanel.querySelectorAll('.finetune-color-row').forEach(r => r.classList.remove('drag-over'));
                        if (row && row.dataset.ftKey !== dragSrcKey) row.classList.add('drag-over');
                        e.dataTransfer.dropEffect = 'move';
                    });

                    ftPanel.addEventListener('dragleave', (e) => {
                        const row = e.target.closest('[data-ft-key]');
                        if (row) row.classList.remove('drag-over');
                    });

                    ftPanel.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const dstRow = e.target.closest('[data-ft-key]');
                        if (!dstRow || !dragSrcKey || dstRow.dataset.ftKey === dragSrcKey) return;
                        const dstKey = dstRow.dataset.ftKey;
                        // Swap color picker values
                        const srcInp = document.getElementById(dragSrcKey);
                        const dstInp = document.getElementById(dstKey);
                        if (srcInp && dstInp) {
                            const tmp = srcInp.value;
                            srcInp.value = dstInp.value;
                            dstInp.value = tmp;
                            // Trigger update
                            this._onFinetuneChange();
                        }
                        ftPanel.querySelectorAll('.finetune-color-row').forEach(r => r.classList.remove('drag-over', 'dragging'));
                        dragSrcKey = null;
                    });
                }
            },

            _loadImageFile(file) {
                const reader = new FileReader();
                const statusEl = document.getElementById('color-extract-status');
                if (statusEl) { statusEl.textContent = 'è¯»å–ä¸­...'; statusEl.style.color = '#86868b'; }

                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        this._colorImgEl = img;
                        // Show preview
                        const preview = document.getElementById('color-img-preview');
                        const hint = document.getElementById('img-upload-hint');
                        if (preview) { preview.src = ev.target.result; preview.style.display = 'block'; }
                        if (hint) hint.style.display = 'none';
                        // Extract
                        this._doExtract(img);
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            },

            reExtractColors() {
                if (this._colorImgEl) this._doExtract(this._colorImgEl);
            },

            _doExtract(img) {
                const statusEl = document.getElementById('color-extract-status');
                try {
                    const canvas = document.getElementById('color-extract-canvas');
                    const MAX = 120; // sample at most 120Ã—120
                    const scale = Math.min(1, MAX / Math.max(img.width, img.height));
                    const w = Math.max(1, Math.round(img.width * scale));
                    const h = Math.max(1, Math.round(img.height * scale));
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, w, h);
                    const data = ctx.getImageData(0, 0, w, h).data;

                    // Quantize each pixel to a 6-bit bucket (4 bits per channel for R,G,B)
                    const buckets = {};
                    for (let i = 0; i < data.length; i += 4) {
                        const a = data[i + 3];
                        if (a < 128) continue; // skip transparent
                        const r = data[i] & 0xF0;
                        const g = data[i + 1] & 0xF0;
                        const b = data[i + 2] & 0xF0;
                        const key = (r << 16) | (g << 8) | b;
                        buckets[key] = (buckets[key] || 0) + 1;
                    }

                    // Sort by frequency, pick diverse top candidates
                    const sorted = Object.entries(buckets)
                        .sort((a, b) => b[1] - a[1])
                        .map(([key]) => {
                            const k = parseInt(key);
                            const r = (k >> 16) & 0xFF;
                            const g = (k >> 8) & 0xFF;
                            const b = k & 0xFF;
                            return { r, g, b };
                        });

                    // Greedy diversity selection: pick colors that are "far" from already selected
                    const selected = [];
                    const colorDist = (a, b) => {
                        const dr = a.r - b.r, dg = a.g - b.g, db = a.b - b.b;
                        return Math.sqrt(dr * dr + dg * dg + db * db);
                    };
                    for (const c of sorted) {
                        if (selected.length >= 6) break;
                        const minDist = selected.reduce((min, s) => Math.min(min, colorDist(c, s)), Infinity);
                        if (selected.length === 0 || minDist > 40) selected.push(c);
                    }
                    // If we got fewer than 6, fill with variants
                    while (selected.length < 6) {
                        const base = selected[0] || { r: 100, g: 100, b: 200 };
                        const idx = selected.length;
                        selected.push({
                            r: Math.min(255, base.r + idx * 25),
                            g: Math.min(255, base.g + idx * 15),
                            b: Math.min(255, base.b + idx * 10)
                        });
                    }

                    // Preserve previous colors before overwriting
                    if (this._extractedColors && this._extractedColors.length > 0) {
                        this._prevExtractedColors = [...this._extractedColors];
                    }

                    this._extractedColors = selected.map(c => {
                        return '#' + [c.r, c.g, c.b].map(v => v.toString(16).padStart(2, '0')).join('');
                    });

                    // Show raw scheme cards immediately
                    document.getElementById('color-swatches-wrap').style.display = 'block';
                    this._rawScheme = this._computeRawScheme(this._extractedColors);
                    this._rawScheme2 = this._computeRawScheme2(this._extractedColors);
                    this._showRawScheme(this._rawScheme, 'raw-scheme-strip', 'raw-scheme-roles');
                    this._showRawScheme(this._rawScheme2, 'raw-scheme-strip2', 'raw-scheme-roles2');
                    this._aiRefinedSchemes = null;

                    if (statusEl) { statusEl.textContent = 'âœ… å·²æå–ï¼ŒAI ä¼˜åŒ–ä¸­â€¦'; statusEl.style.color = '#86868b'; }
                    // Trigger AI in background
                    this._aiRefineColors();
                } catch (e) {
                    if (statusEl) { statusEl.textContent = 'âŒ æå–å¤±è´¥: ' + (e.message || e); statusEl.style.color = '#ff3b30'; }
                    console.error('Color extract error', e);
                }
            },

            // â”€â”€ Build raw scheme from extracted colors (luminance/saturation heuristic) â”€â”€
            // version 1: richest saturated color as header
            _computeRawScheme(colors) {
                const hexToHsl = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16) / 255;
                    const g = parseInt(hex.slice(3, 5), 16) / 255;
                    const b = parseInt(hex.slice(5, 7), 16) / 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    const lum = (max + min) / 2;
                    const sat = max === min ? 0 : (max - min) / (lum < 0.5 ? max + min : 2 - max - min);
                    let hue = 0;
                    if (max !== min) {
                        const d = max - min;
                        if (max === r) hue = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                        else if (max === g) hue = ((b - r) / d + 2) / 6;
                        else hue = ((r - g) / d + 4) / 6;
                    }
                    return { hex, hue, sat, lum };
                };
                const lightTint = (hex, factor) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return '#' + [r, g, b].map(v => Math.round(v + (255 - v) * factor).toString(16).padStart(2, '0')).join('');
                };
                const analyzed = colors.map(hexToHsl);
                const bySat = [...analyzed].sort((a, b) => b.sat - a.sat);
                const byLum = [...analyzed].sort((a, b) => a.lum - b.lum);

                const headerCandidate = bySat[0];
                const header_bg = headerCandidate.hex;
                const header_text = headerCandidate.lum < 0.55 ? '#ffffff' : '#1a1a2e';
                const darkCandidates = byLum.filter(c => c.lum < 0.45);
                const body_text = darkCandidates.length > 0 ? darkCandidates[0].hex : '#1d1d1f';
                const lightestExtracted = byLum[byLum.length - 1];
                const canvas_bg = lightestExtracted.lum >= 0.80 ? lightestExtracted.hex : lightTint(header_bg, 0.88);
                const odd_row_bg = lightTint(header_bg, 0.92);
                const border = lightTint(header_bg, 0.80);

                return { name: 'åŸå§‹æ–¹æ¡ˆä¸€', header_bg, header_text, body_text, odd_row_bg, border, canvas_bg };
            },

            // version 2: second-rich saturation as header, brighter canvas_bg tint
            _computeRawScheme2(colors) {
                const hexToHsl = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16) / 255;
                    const g = parseInt(hex.slice(3, 5), 16) / 255;
                    const b = parseInt(hex.slice(5, 7), 16) / 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    const lum = (max + min) / 2;
                    const sat = max === min ? 0 : (max - min) / (lum < 0.5 ? max + min : 2 - max - min);
                    return { hex, lum, sat };
                };
                const lightTint = (hex, factor) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return '#' + [r, g, b].map(v => Math.round(v + (255 - v) * factor).toString(16).padStart(2, '0')).join('');
                };
                const analyzed = colors.map(hexToHsl);
                const bySat = [...analyzed].sort((a, b) => b.sat - a.sat);
                const byLum = [...analyzed].sort((a, b) => a.lum - b.lum);

                // Use 2nd most saturated as header (if available), else the 1st
                const headerCandidate = bySat[1] && bySat[1].sat > 0.15 ? bySat[1] : bySat[0];
                const header_bg = headerCandidate.hex;
                const header_text = headerCandidate.lum < 0.55 ? '#ffffff' : '#1a1a2e';
                const darkCandidates = byLum.filter(c => c.lum < 0.45);
                const body_text = darkCandidates.length > 0 ? darkCandidates[0].hex : '#1d1d1f';
                // Use lightest for canvas_bg, but lighten more (target 0.93)
                const lightestExtracted = byLum[byLum.length - 1];
                const canvas_bg = lightestExtracted.lum >= 0.87 ? lightestExtracted.hex : lightTint(header_bg, 0.93);
                const odd_row_bg = lightTint(header_bg, 0.94);
                const border = lightTint(header_bg, 0.85);

                return { name: 'åŸå§‹æ–¹æ¡ˆäºŒ', header_bg, header_text, body_text, odd_row_bg, border, canvas_bg };
            },

            // â”€â”€ Render raw scheme card â”€â”€
            _showRawScheme(scheme, stripId, rolesId) {
                stripId = stripId || 'raw-scheme-strip';
                rolesId = rolesId || 'raw-scheme-roles';
                const strip = document.getElementById(stripId);
                const roles = document.getElementById(rolesId);
                if (!strip) return;
                const keys = ['header_bg', 'canvas_bg', 'odd_row_bg', 'border', 'body_text', 'header_text'];
                strip.innerHTML = keys.map(k => `<span style="background:${scheme[k]}" title="${k}"></span>`).join('');
                if (roles) roles.textContent = `è¡¨å¤´: ${scheme.header_bg.toUpperCase()}  èƒŒæ™¯: ${scheme.canvas_bg.toUpperCase()}  æ–‡å­—: ${scheme.body_text.toUpperCase()}`;
            },

            // â”€â”€ Render a scheme card in the AI list â”€â”€
            _renderSchemeCard(scheme, idx) {
                const card = document.createElement('div');
                card.className = 'scheme-card';
                card.dataset.schemeIdx = idx;

                const keys = ['header_bg', 'canvas_bg', 'odd_row_bg', 'border', 'body_text', 'header_text'];
                const stripHtml = keys.map(k => `<span style="background:${scheme[k]}" title="${k}"></span>`).join('');

                const labels = [
                    ['è¡¨å¤´èƒŒæ™¯', scheme.header_bg],
                    ['å†…å®¹æ–‡å­—', scheme.body_text],
                    ['ç”»å¸ƒèƒŒæ™¯', scheme.canvas_bg],
                ].map(([l, c]) => `<span style="margin-right:8px;"><span style="display:inline-block;width:8px;height:8px;border-radius:2px;background:${c};margin-right:2px;vertical-align:middle;"></span>${l}: ${c.toUpperCase()}</span>`).join('');

                card.innerHTML = `
                    <div style="display:flex;align-items:center;justify-content:space-between;">
                        <span style="font-size:10px;font-weight:600;color:#1d1d1f;">${scheme.name || 'æ–¹æ¡ˆ ' + (idx + 1)}</span>
                        <span style="font-size:9px;color:#86868b;">AI æ¨è</span>
                    </div>
                    <div class="scheme-strip">${stripHtml}</div>
                    <div style="font-size:8.5px;color:#86868b;margin-bottom:6px;line-height:1.6;">${labels}</div>
                    <button class="scheme-apply-btn" onclick="App.applyScheme(${idx})">âœ¨ ä½¿ç”¨æ­¤æ–¹æ¡ˆ</button>`;

                document.getElementById('ai-schemes-list').appendChild(card);
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  AI COLOR REFINEMENT â€” 3 schemes via DeepSeek
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async _aiRefineColors() {
                const statusEl = document.getElementById('color-extract-status');
                const badge = document.getElementById('ai-scheme-badge');
                const loading = document.getElementById('ai-schemes-loading');
                const listEl = document.getElementById('ai-schemes-list');
                const apiKey = (document.getElementById('ai-apikey')?.value || '').trim();
                const colors = this._extractedColors;
                if (!colors || colors.length === 0) return;

                if (!apiKey) {
                    if (badge) badge.textContent = 'ï¼ˆéœ€å¡«å†™ API Keyï¼‰';
                    return;
                }

                if (loading) loading.style.display = 'block';
                if (listEl) listEl.innerHTML = '';
                if (badge) badge.textContent = '';

                const systemPrompt = `ä½ æ˜¯ä¸“ä¸šçš„ UI é…è‰²å¸ˆã€‚è¯·åŸºäºç»™å®šçš„å›¾ç‰‡æå–è‰²ï¼Œä¸ºæ•°æ®è¡¨æ ¼ç”Ÿæˆ 3 å¥—å¾®è°ƒé…è‰²æ–¹æ¡ˆã€‚

ã€é‡è¦ã€‘è¿™ 3 å¥—æ–¹æ¡ˆå¿…é¡»ä»¥åŸå§‹æå–è‰²ä¸ºåŸºç¡€ï¼Œåªåšè½»å¾®çš„è‰²ç›¸/æ˜åº¦/é¥±å’Œåº¦å¾®è°ƒï¼Œä¸èƒ½äº§ç”Ÿä¸åŸå§‹è‰²è°ƒå·®å¼‚è¿‡å¤§çš„é¢œè‰²ã€‚
å°¤å…¶ï¼šheader_bg å’Œ canvas_bg å¿…é¡»ä¸å¯¹åº”åŸå§‹è‰²åœ¨è‰²ç³»ä¸Šä¸€è‡´ï¼ˆRGB å„é€šé“åå·®ä¸è¶…è¿‡ 40ï¼‰ã€‚

æ¯å¥—æ–¹æ¡ˆåŒ…å« 6 ä¸ªå­—æ®µï¼š
- header_bg: è¡¨å¤´èƒŒæ™¯è‰²ï¼ˆåŸºäºå›¾ç‰‡æœ€é¥±å’Œè‰²å¾®è°ƒï¼Œä¸ canvas_bg è‰²è°ƒæ˜æ˜¾ä¸åŒï¼Œæœ‰è´¨æ„Ÿï¼‰
- header_text: è¡¨å¤´æ–‡å­—è‰²ï¼ˆä¸ header_bg å½¢æˆé«˜å¯¹æ¯”ï¼Œé€šå¸¸ç™½è‰² #ffffff æˆ–æ·±è‰²ï¼‰
- body_text: æ•°æ®è¡Œæ–‡å­—è‰²ï¼ˆæ·±è‰²ï¼Œå¯è¯»æ€§å¼ºï¼Œé€šå¸¸ #1d1d1f æˆ–æ·±ç°ï¼‰
- odd_row_bg: å¥‡æ•°è¡Œåº•è‰²ï¼ˆææ·¡ï¼Œé«˜äº®åº¦ lum>0.88ï¼Œè½»å¾®ä¸ canvas_bg åŒºåˆ†ï¼‰
- border: å•å…ƒæ ¼è¾¹æ¡†è‰²ï¼ˆææ·¡ç»†è…»ï¼Œlum>0.82ï¼‰
- canvas_bg: ç”»å¸ƒèƒŒæ™¯è‰²ï¼ˆåŸºäºå›¾ç‰‡æœ€æµ…/æœ€äº®è‰²å¾®è°ƒï¼Œä¸ header_bg è‰²è°ƒæœ‰æ‰€åŒºåˆ«ï¼‰

3 å¥—æ–¹æ¡ˆåç§°åˆ†åˆ«ä¸ºï¼šå¾®è°ƒæ–¹æ¡ˆä¸€ã€å¾®è°ƒæ–¹æ¡ˆäºŒã€å¾®è°ƒæ–¹æ¡ˆä¸‰
æ¯å¥—çš„å¾®è°ƒæ–¹å‘ï¼š
1. "å¾®è°ƒæ–¹æ¡ˆä¸€"ï¼šåœ¨åŸå§‹è‰²åŸºç¡€ä¸Šæ•´ä½“ç•¥å¾®æå‡é¥±å’Œåº¦ï¼Œä½¿è¡¨æ ¼æ›´é²œæ˜
2. "å¾®è°ƒæ–¹æ¡ˆäºŒ"ï¼šåœ¨åŸå§‹è‰²åŸºç¡€ä¸Šç•¥å¾®é™ä½é¥±å’Œåº¦/æå‡äº®åº¦ï¼Œä½¿è¡¨æ ¼æ›´æŸ”å’Œæ¸…çˆ½
3. "å¾®è°ƒæ–¹æ¡ˆä¸‰"ï¼šåœ¨åŸå§‹è‰²åŸºç¡€ä¸Šå¾®è°ƒè‰²ç›¸ï¼ˆÂ±10Â°ä»¥å†…ï¼‰ï¼Œç»™å‡ºä¸€ä¸ªæœ‰ç»†å¾®å·®å¼‚çš„ç¬¬ä¸‰é€‰æ‹©

è§„åˆ™ï¼š
- æ‰€æœ‰é¢œè‰²å¿…é¡»æ˜¯ #rrggbb æ ¼å¼ï¼ˆ6ä½åå…­è¿›åˆ¶å°å†™ï¼‰
- å¿…é¡»ç¬¦åˆ WCAG AA å¯¹æ¯”åº¦ï¼Œbody_text/header_text è¦æ˜“è¯»
- odd_row_bgã€borderã€canvas_bg å¿…é¡»åæµ…ï¼ˆlum > 0.82ï¼‰
- header_bg ä¸ canvas_bg ä¹‹é—´æ˜åº¦å·® > 0.35ï¼Œç¡®ä¿è¡¨å¤´å’ŒèƒŒæ™¯åŒºåˆ†æ˜æ˜¾

åªè¿”å›çº¯ JSON æ•°ç»„ï¼Œä¸å«ä»»ä½• markdown æˆ–è¯´æ˜ï¼š
[{"name":"å¾®è°ƒæ–¹æ¡ˆä¸€","header_bg":"#...","header_text":"#...","body_text":"#...","odd_row_bg":"#...","border":"#...","canvas_bg":"#..."},{"name":"å¾®è°ƒæ–¹æ¡ˆäºŒ",...},{"name":"å¾®è°ƒæ–¹æ¡ˆä¸‰",...}]`;

                const userMsg = `å›¾ç‰‡æå–çš„ 6 ä¸ªä¸»è‰²ï¼š${colors.join(', ')}\nåŸå§‹æ–¹æ¡ˆä¸­ header_bg=${this._rawScheme?.header_bg || colors[0]}ï¼Œcanvas_bg=${this._rawScheme?.canvas_bg || colors[colors.length - 1]}\nè¯·åœ¨åŸå§‹è‰²åŸºç¡€ä¸Šç”Ÿæˆ 3 å¥—å¾®è°ƒé…è‰²æ–¹æ¡ˆï¼Œä¿æŒè‰²ç³»ä¸€è‡´ï¼Œåªåšç»†å¾®è°ƒæ•´ã€‚`;

                try {
                    const res = await fetch('https://api.deepseek.com/chat/completions', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey },
                        body: JSON.stringify({
                            model: 'deepseek-chat',
                            messages: [
                                { role: 'system', content: systemPrompt },
                                { role: 'user', content: userMsg }
                            ],
                            max_tokens: 600,
                            temperature: 0.6
                        })
                    });

                    const data = await res.json();
                    if (data.error) throw new Error(data.error.message || JSON.stringify(data.error));

                    let raw = (data.choices?.[0]?.message?.content || '').trim();
                    raw = raw.replace(/```[a-z]*\n?/gi, '').replace(/```/g, '').trim();
                    const arrMatch = raw.match(/\[[\s\S]*\]/);
                    if (!arrMatch) throw new Error('AI æœªè¿”å›æœ‰æ•ˆ JSON æ•°ç»„');

                    const schemes = JSON.parse(arrMatch[0]);
                    const required = ['header_bg', 'header_text', 'body_text', 'odd_row_bg', 'border', 'canvas_bg'];
                    const valid = schemes.filter(s => required.every(k => s[k] && /^#[0-9a-fA-F]{6}$/.test(s[k])));
                    if (valid.length === 0) throw new Error('æ‰€æœ‰æ–¹æ¡ˆå­—æ®µæ ¡éªŒå¤±è´¥');

                    this._aiRefinedSchemes = valid;
                    if (loading) loading.style.display = 'none';
                    if (badge) badge.textContent = `${valid.length} å¥—`;
                    if (listEl) listEl.innerHTML = '';
                    valid.forEach((s, i) => this._renderSchemeCard(s, i));
                    if (statusEl) { statusEl.textContent = `âœ¨ AI æ¨èäº† ${valid.length} å¥—æ–¹æ¡ˆ`; statusEl.style.color = '#34c759'; }

                } catch (e) {
                    console.error('AI refine colors error:', e);
                    if (loading) loading.style.display = 'none';
                    if (badge) badge.textContent = 'ç”Ÿæˆå¤±è´¥';
                    if (listEl) listEl.innerHTML = `<div style="font-size:10px;color:#ff3b30;padding:8px;">âš ï¸ ${e.message || e}</div>`;
                    if (statusEl) { statusEl.textContent = 'âš ï¸ AI ä¼˜åŒ–å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æå–è‰²'; statusEl.style.color = '#ff9500'; }
                }
            },


            // Compute role map from extracted colors (same logic as applyExtractedColors)

            _getColorRoleMap(colors) {
                const analyze = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16) / 255, g = parseInt(hex.slice(3, 5), 16) / 255, b = parseInt(hex.slice(5, 7), 16) / 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    const lum = (max + min) / 2;
                    const sat = max === min ? 0 : (max - min) / (lum < 0.5 ? max + min : 2 - max - min);
                    return { hex, lum, sat };
                };
                const analyzed = colors.map(analyze);
                const byLum = [...analyzed].sort((a, b) => a.lum - b.lum);
                const bySat = [...analyzed].sort((a, b) => b.sat - a.sat);
                const bg = byLum[0].hex;
                const textMain = byLum[1] ? byLum[1].hex : byLum[0].hex;
                const textContrast = byLum[byLum.length - 1].hex;
                const highlight = bySat[0].hex;
                const sidebar = bySat[1] ? bySat[1].hex : bySat[0].hex;
                const header = bySat[2] ? bySat[2].hex : sidebar;
                const ROLE_NAMES = {
                    [bg]: { label: 'ç”»å¸ƒèƒŒæ™¯', icon: 'ğŸ–¼ï¸', desc: 'æ•´ä½“èƒŒæ™¯åº•è‰²' },
                    [textMain]: { label: 'å†…å®¹æ–‡å­—', icon: 'ğŸ”¤', desc: 'æ•°æ®è¡Œæ–‡å­—è‰²' },
                    [textContrast]: { label: 'è¡¨å¤´æ–‡å­—', icon: 'ğŸ“', desc: 'è¡¨å¤´è¡Œæ–‡å­—è‰²' },
                    [highlight]: { label: 'é«˜äº®/è¾¹æ¡†', icon: 'âœ¨', desc: 'å•å…ƒæ ¼è¾¹çº¿è‰²' },
                    [sidebar]: { label: 'å¥‡æ•°è¡Œåº•', icon: 'ğŸ“Š', desc: 'å¥‡æ•°è¡Œæ·¡è‰²åº•' },
                    [header]: { label: 'å‚è€ƒè‰²', icon: 'ğŸ¯', desc: 'è¾…åŠ©å‚è€ƒè‰²' },
                };
                // Handle duplicates: assign each analyzed item its role
                return colors.map(hex => ROLE_NAMES[hex] || { label: 'æå–è‰²', icon: 'ğŸ¨', desc: hex.toUpperCase() });
            },

            _renderSwatches() {
                const row = document.getElementById('color-swatches-row');
                const labelsRow = document.getElementById('color-role-labels');
                if (!row) return;

                row.innerHTML = '';
                if (labelsRow) labelsRow.innerHTML = '';

                // Show previous palette if available
                const prevRow = document.getElementById('color-prev-row');
                const prevSection = document.getElementById('color-prev-section');
                if (this._prevExtractedColors && this._prevExtractedColors.length > 0) {
                    if (prevSection) prevSection.style.display = 'block';
                    if (prevRow) {
                        prevRow.innerHTML = '';
                        this._prevExtractedColors.forEach((hex, i) => {
                            const swatch = document.createElement('div');
                            swatch.className = 'color-swatch';
                            swatch.style.cssText = `background:${hex}; width:28px; height:28px; border-radius:6px; opacity:0.85; flex-shrink:0;`;
                            swatch.title = hex + ' ï¼ˆç‚¹å‡»æ›¿æ¢å½“å‰ç¬¬' + (i + 1) + 'è‰²ï¼‰';
                            swatch.addEventListener('click', () => {
                                if (i < this._extractedColors.length) {
                                    this._extractedColors[i] = hex;
                                    this._renderSwatches();
                                }
                            });
                            prevRow.appendChild(swatch);
                        });
                    }
                } else {
                    if (prevSection) prevSection.style.display = 'none';
                }

                // Compute role map for current extracted colors
                const roleMap = this._getColorRoleMap(this._extractedColors);

                // Render swatches with role labels
                this._extractedColors.forEach((hex, i) => {
                    const role = roleMap[i];

                    // Swatch column wrapper
                    const col = document.createElement('div');
                    col.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:3px;';

                    // Swatch circle
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.background = hex;
                    swatch.title = `${role.icon} ${role.label}\n${hex.toUpperCase()} â€” ${role.desc}\nï¼ˆç‚¹å‡»å¾®è°ƒé¢œè‰²ï¼‰`;
                    swatch.innerHTML = '<span class="swatch-edit-icon">âœï¸</span>';
                    swatch.addEventListener('click', () => {
                        this._currentSwatchIndex = i;
                        const picker = document.getElementById('swatch-color-picker');
                        if (!picker) return;
                        picker.value = hex;
                        const rect = swatch.getBoundingClientRect();
                        picker.style.position = 'fixed';
                        picker.style.left = rect.left + 'px';
                        picker.style.top = rect.bottom + 4 + 'px';
                        picker.style.opacity = '0';
                        picker.style.pointerEvents = 'auto';
                        picker.click();
                    });
                    col.appendChild(swatch);

                    // Role icon badge
                    const iconEl = document.createElement('div');
                    iconEl.style.cssText = 'font-size:10px; line-height:1;';
                    iconEl.textContent = role.icon;
                    col.appendChild(iconEl);

                    // Role label
                    const labelEl = document.createElement('div');
                    labelEl.style.cssText = 'font-size:8.5px;font-weight:600;color:#1d1d1f;text-align:center;letter-spacing:-0.02em;line-height:1.2;max-width:36px;word-break:break-all;';
                    labelEl.textContent = role.label;
                    col.appendChild(labelEl);

                    row.appendChild(col);
                });

                // Clear old hex labels row (now shown in swatches)
                if (labelsRow) labelsRow.innerHTML = '';
            },

            // Intelligently map 6 colors by luminance + saturation to role names
            _mapColorsToRoles(colors) {
                const analyze = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16) / 255;
                    const g = parseInt(hex.slice(3, 5), 16) / 255;
                    const b = parseInt(hex.slice(5, 7), 16) / 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    const lum = (max + min) / 2;
                    const sat = max === min ? 0 : (max - min) / (lum < 0.5 ? max + min : 2 - max - min);
                    return { lum, sat };
                };
                return colors.map(c => analyze(c));
            },

            // â”€â”€ Apply a color scheme ('raw', 'raw2', '__history__', or AI scheme index) â”€â”€
            applyScheme(schemeKey) {
                let scheme;
                if (schemeKey === 'raw') {
                    scheme = this._rawScheme;
                } else if (schemeKey === 'raw2') {
                    scheme = this._rawScheme2;
                } else if (schemeKey === '__history__') {
                    scheme = this._historyReapplyScheme;
                    this._historyReapplyScheme = null;
                } else {
                    scheme = this._aiRefinedSchemes?.[parseInt(schemeKey)];
                }
                if (!scheme) {
                    const st = document.getElementById('color-extract-status');
                    if (st) { st.textContent = 'âš ï¸ æ–¹æ¡ˆä¸å­˜åœ¨ï¼Œè¯·å…ˆæå–é¢œè‰²'; st.style.color = '#ff9500'; }
                    return;
                }

                const { header_bg, header_text, body_text, odd_row_bg, border, canvas_bg } = scheme;

                // Highlight the selected card
                document.querySelectorAll('.scheme-card').forEach(c => c.classList.remove('selected'));
                if (schemeKey === 'raw') {
                    document.getElementById('raw-scheme-card')?.classList.add('selected');
                } else {
                    const cards = document.getElementById('ai-schemes-list')?.querySelectorAll('.scheme-card');
                    if (cards?.[parseInt(schemeKey)]) cards[parseInt(schemeKey)].classList.add('selected');
                }

                // Apply to UI controls
                const cfgColor = document.getElementById('cfg-color');
                if (cfgColor) cfgColor.value = this._toHex6(header_bg);

                const cfgBgColor = document.getElementById('cfg-bg-color');
                if (cfgBgColor) cfgBgColor.value = this._toHex6(canvas_bg);

                const cfgTransparent = document.getElementById('cfg-transparent');
                if (cfgTransparent) cfgTransparent.checked = false;

                // Store palette for buildTableOption
                this._appliedPalette = {
                    bg: canvas_bg,
                    textMain: body_text,
                    textContrast: header_text,
                    highlight: border,
                    sidebar: odd_row_bg,
                    header: header_bg,
                };

                this.render(true);

                const st = document.getElementById('color-extract-status');
                if (st) {
                    st.textContent = `âœ… "${scheme.name || 'æ–¹æ¡ˆ'}" å·²åº”ç”¨ï¼`;
                    st.style.color = '#34c759';
                }

                // Show role mapping table
                const mapEl = document.getElementById('color-map-result');
                if (mapEl) {
                    const roles = [
                        { role: 'è¡¨å¤´èƒŒæ™¯', color: header_bg, desc: 'è¡¨å¤´è¡ŒèƒŒæ™¯è‰²' },
                        { role: 'è¡¨å¤´æ–‡å­—', color: header_text, desc: 'è¡¨å¤´è¡Œæ–‡å­—è‰²' },
                        { role: 'å†…å®¹æ–‡å­—', color: body_text, desc: 'æ•°æ®è¡Œæ–‡å­—è‰²' },
                        { role: 'å¥‡æ•°è¡Œåº•', color: odd_row_bg, desc: 'äº¤æ›¿è¡Œæ·¡è‰²åº•' },
                        { role: 'è¾¹æ¡†é¢œè‰²', color: border, desc: 'å•å…ƒæ ¼è¾¹çº¿è‰²' },
                        { role: 'ç”»å¸ƒèƒŒæ™¯', color: canvas_bg, desc: 'æ•´ä½“ç”»å¸ƒèƒŒæ™¯' },
                    ];
                    mapEl.innerHTML = `<div style="font-size:10px;font-weight:600;color:#86868b;margin-bottom:6px;">å·²åº”ç”¨Â·é…è‰²è§’è‰²æ˜ å°„</div>` +
                        roles.map(item => `<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                            <div style="width:16px;height:16px;border-radius:4px;background:${item.color};border:1px solid rgba(0,0,0,0.1);flex-shrink:0;"></div>
                            <span style="font-size:10px;font-weight:600;color:#1d1d1f;min-width:50px;">${item.role}</span>
                            <span style="font-size:9px;color:#86868b;">${item.color.toUpperCase()} â€” ${item.desc}</span>
                        </div>`).join('');
                    mapEl.style.display = 'block';
                }

                // â”€â”€ Show fine-tune panel (5 colors + odd-row opacity slider) â”€â”€
                const ftPanel = document.getElementById('scheme-finetune-panel');
                if (ftPanel) {
                    const setFt = (id, hexId, val) => {
                        const inp = document.getElementById(id);
                        const lbl = document.getElementById(hexId);
                        const v = this._toHex6(val || '#888888');
                        if (inp) inp.value = v;
                        if (lbl) lbl.textContent = v.toUpperCase();
                    };
                    setFt('ft-header-color', 'ft-header-hex', header_bg);
                    setFt('ft-header-text', 'ft-header-text-hex', header_text);
                    setFt('ft-body-text', 'ft-body-text-hex', body_text);
                    setFt('ft-border', 'ft-border-hex', border);
                    setFt('ft-bg-color', 'ft-bg-hex', canvas_bg);
                    // Odd-row preview at default 60% opacity
                    const opacitySlider = document.getElementById('ft-odd-opacity');
                    const opacityVal = document.getElementById('ft-odd-opacity-val');
                    const oddPreview = document.getElementById('ft-odd-preview');
                    const oddHexEl = document.getElementById('ft-odd-row-hex');
                    if (opacitySlider) opacitySlider.value = 60;
                    if (opacityVal) opacityVal.textContent = '60%';
                    const blended = this._blendHexAlpha(header_bg, canvas_bg, 0.60);
                    if (oddPreview) oddPreview.style.background = blended;
                    if (oddHexEl) oddHexEl.textContent = blended.toUpperCase();
                    ftPanel.style.display = 'block';
                }

                // â”€â”€ Record history â”€â”€
                this._addToHistory(scheme);
            },

            // Fine-tune panel live update â€” odd-row uses opacity slider linked to header color
            _onFinetuneChange() {
                const get = (id, hexId) => {
                    const inp = document.getElementById(id);
                    const lbl = document.getElementById(hexId);
                    const v = inp ? inp.value : null;
                    if (lbl && v) lbl.textContent = v.toUpperCase();
                    return v;
                };
                const hColor = get('ft-header-color', 'ft-header-hex');
                const htColor = get('ft-header-text', 'ft-header-text-hex');
                const btColor = get('ft-body-text', 'ft-body-text-hex');
                const brdColor = get('ft-border', 'ft-border-hex');
                const bgColor = get('ft-bg-color', 'ft-bg-hex');

                // Odd-row: user picks color directly, opacity slider blends it with bg
                const oddPicker = document.getElementById('ft-odd-row');
                const opacitySlider = document.getElementById('ft-odd-opacity');
                const opacityVal = document.getElementById('ft-odd-opacity-val');
                const oddHexEl = document.getElementById('ft-odd-row-hex');
                const oddBase = oddPicker ? oddPicker.value : (hColor || '#007aff');
                const opacity = opacitySlider ? parseInt(opacitySlider.value) : 60;
                if (opacityVal) opacityVal.textContent = opacity + '%';
                const oddColor = this._blendHexAlpha(oddBase, bgColor || '#ffffff', opacity / 100);
                if (oddHexEl) {
                    oddPicker.style.boxShadow = '0 0 0 2px rgba(0,0,0,0.08)';
                    oddHexEl.textContent = oddColor.toUpperCase();
                }

                // Sync main pickers
                const cfgColor = document.getElementById('cfg-color');
                if (cfgColor && hColor) cfgColor.value = hColor;
                const cfgBgColor = document.getElementById('cfg-bg-color');
                if (cfgBgColor && bgColor) cfgBgColor.value = bgColor;

                // Update full palette
                if (this._appliedPalette) {
                    if (hColor) this._appliedPalette.header = hColor;
                    if (htColor) this._appliedPalette.textContrast = htColor;
                    if (btColor) this._appliedPalette.textMain = btColor;
                    if (oddColor) this._appliedPalette.sidebar = oddColor;
                    if (brdColor) this._appliedPalette.highlight = brdColor;
                    if (bgColor) this._appliedPalette.bg = bgColor;
                }
                this.render(false);
            },

            // Helper: blend hexFg on hexBg at alpha (0..1), return opaque hex result
            _blendHexAlpha(hexFg, hexBg, alpha) {
                hexFg = (hexFg || '#888888').replace('#', '');
                hexBg = (hexBg || '#ffffff').replace('#', '');
                const pr = parseInt(hexFg.slice(0, 2), 16) || 0;
                const pg = parseInt(hexFg.slice(2, 4), 16) || 0;
                const pb = parseInt(hexFg.slice(4, 6), 16) || 0;
                const br = parseInt(hexBg.slice(0, 2), 16) || 255;
                const bg2 = parseInt(hexBg.slice(2, 4), 16) || 255;
                const bb = parseInt(hexBg.slice(4, 6), 16) || 255;
                const nr = Math.round(pr * alpha + br * (1 - alpha));
                const ng = Math.round(pg * alpha + bg2 * (1 - alpha));
                const nb = Math.round(pb * alpha + bb * (1 - alpha));
                return '#' + [nr, ng, nb].map(v => Math.max(0, Math.min(255, v)).toString(16).padStart(2, '0')).join('');
            },

            // â”€â”€ Color History â”€â”€
            _colorHistory: [],

            _addToHistory(scheme) {
                // Avoid consecutive duplicates
                const last = this._colorHistory[0];
                if (last && last.header_bg === scheme.header_bg && last.canvas_bg === scheme.canvas_bg) return;
                this._colorHistory.unshift({
                    name: scheme.name || 'æ–¹æ¡ˆ',
                    header_bg: scheme.header_bg,
                    canvas_bg: scheme.canvas_bg,
                    scheme: scheme
                });
                if (this._colorHistory.length > 10) this._colorHistory.pop();
                this._renderHistory();
            },

            _renderHistory() {
                const listEl = document.getElementById('color-history-list');
                const details = document.getElementById('color-history-details');
                const countEl = document.getElementById('history-count');
                if (!listEl || !details) return;
                if (this._colorHistory.length === 0) {
                    details.style.display = 'none';
                    return;
                }
                details.style.display = 'block';
                if (countEl) countEl.textContent = `(${this._colorHistory.length})`;
                listEl.innerHTML = '';
                this._colorHistory.forEach((entry, i) => {
                    const row = document.createElement('div');
                    row.className = 'history-row';
                    row.title = `é‡æ–°åº”ç”¨: ${entry.name}`;
                    const keys = ['header_bg', 'canvas_bg', 'odd_row_bg', 'border', 'body_text', 'header_text'];
                    const stripHtml = keys.map(k => {
                        const c = entry.scheme[k] || '#cccccc';
                        return `<span style="background:${c}" title="${k}"></span>`;
                    }).join('');
                    row.innerHTML = `
                        <div class="history-row-strip">${stripHtml}</div>
                        <span class="history-row-name" title="${entry.name}">${entry.name}</span>
                        <button onclick="App._reapplyHistory(${i})" style="font-size:9px;padding:2px 6px;border-radius:10px;background:rgba(0,122,255,0.1);color:#007aff;border:none;cursor:pointer;flex-shrink:0;">åº”ç”¨</button>
                    `;
                    listEl.appendChild(row);
                });
            },

            _reapplyHistory(idx) {
                const entry = this._colorHistory[idx];
                if (!entry) return;
                // Temporarily inject back so applyScheme can find it
                this._historyReapplyScheme = entry.scheme;
                this.applyScheme('__history__');
            },

            // backward-compat alias
            applyExtractedColors() { this.applyScheme('raw'); },


            _toHex6(hex) {
                if (!hex || hex.length < 4) return '#000000';
                if (hex.length === 4) {
                    return '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                }
                return hex.substring(0, 7);
            },


            clearData() {
                document.getElementById('data-input').value = '';
                document.getElementById('parse-status').textContent = '';
                this.chart.clear();
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  HD EXPORT â€” 300dpi (pixelRatio â‰ˆ 4)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            getPixelRatio() {
                return Math.max(1, parseInt(document.getElementById('cfg-quality').value || '2', 10));
            },

            base64ToBlob(b64) {
                const bin = atob(b64);
                const arr = new Uint8Array(bin.length);
                for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
                return new Blob([arr], { type: 'image/png' });
            },

            exportHD() {
                if (!this.chart) return;
                const fileName = document.getElementById('cfg-filename').value.trim() || 'ECharts_Table';
                const pr = this.getPixelRatio();
                const label = pr >= 8 ? '8K' : '4K';
                const config = this.getConfig();
                const isTransparent = config.transparent;
                const radius = (config.borderRadius || 0) * pr;

                // For export: always render with canvas_bg (unless transparent toggled)
                let bg = isTransparent ? 'transparent' : (config.bgColor || '#ffffff');

                try {
                    const dataUrl = this.chart.getDataURL({ type: 'png', pixelRatio: pr, backgroundColor: bg });
                    const suffix = isTransparent ? '_transparent_' : '_';
                    this._clipRoundedCorner(dataUrl, radius, blob => {
                        saveAs(blob, `${fileName}${suffix}${label}.png`);
                    });
                } catch (e) {
                    alert('å¯¼å‡ºå¤±è´¥: ' + (e.message || e));
                }
            },

            exportTransparent() {
                if (!this.chart) return;
                const fileName = document.getElementById('cfg-filename').value.trim() || 'ECharts_Table';
                const pr = this.getPixelRatio();
                const label = pr >= 8 ? '8K' : '4K';
                const config = this.getConfig();
                const radius = (config.borderRadius || 0) * pr;

                try {
                    const dataUrl = this.chart.getDataURL({ type: 'png', pixelRatio: pr, backgroundColor: 'transparent' });
                    this._clipRoundedCorner(dataUrl, radius, blob => {
                        saveAs(blob, `${fileName}_transparent_${label}.png`);
                    });
                } catch (e) {
                    alert('å¯¼å‡ºå¤±è´¥: ' + (e.message || e));
                }
            },

            // Shared helper: clip a dataURL image to rounded corners, call back with Blob
            _clipRoundedCorner(dataUrl, radius, onBlob) {
                if (!radius || radius <= 0) {
                    // No rounding â€” convert directly
                    const b64 = dataUrl.split(',')[1];
                    onBlob(this.base64ToBlob(b64));
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    const cvs = document.createElement('canvas');
                    cvs.width = img.width;
                    cvs.height = img.height;
                    const ctx = cvs.getContext('2d');
                    const r = Math.min(radius, img.width / 2, img.height / 2);
                    ctx.beginPath();
                    ctx.moveTo(r, 0);
                    ctx.lineTo(img.width - r, 0);
                    ctx.quadraticCurveTo(img.width, 0, img.width, r);
                    ctx.lineTo(img.width, img.height - r);
                    ctx.quadraticCurveTo(img.width, img.height, img.width - r, img.height);
                    ctx.lineTo(r, img.height);
                    ctx.quadraticCurveTo(0, img.height, 0, img.height - r);
                    ctx.lineTo(0, r);
                    ctx.quadraticCurveTo(0, 0, r, 0);
                    ctx.closePath();
                    ctx.clip();
                    ctx.drawImage(img, 0, 0);
                    cvs.toBlob(onBlob, 'image/png');
                };
                img.src = dataUrl;
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  OFFSCREEN RENDER for split export
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            _renderOffscreen(data, config, renderMode, bgColor, pixelRatio) {
                return new Promise((resolve, reject) => {
                    const div = document.createElement('div');
                    div.style.cssText = `position:fixed;left:-99999px;top:-99999px;width:${this.state.width}px;height:${this.state.height}px;pointer-events:none;opacity:0;`;
                    document.body.appendChild(div);
                    let offChart = null;
                    try {
                        offChart = echarts.init(div, null, { renderer: 'canvas', devicePixelRatio: 2 });
                        const option = this.buildTableOption(data, config, renderMode);
                        if (!option) throw new Error('æ„å»º option å¤±è´¥');
                        option.animation = false;
                        option.backgroundColor = bgColor;
                        offChart.setOption(option, { notMerge: true });

                        const capture = () => {
                            try {
                                const url = offChart.getDataURL({ type: 'png', pixelRatio, backgroundColor: bgColor });
                                offChart.dispose(); document.body.removeChild(div);
                                resolve(url.split(',')[1]);
                            } catch (err) {
                                offChart.dispose(); document.body.removeChild(div); reject(err);
                            }
                        };
                        let done = false;
                        const once = () => { if (!done) { done = true; capture(); } };
                        requestAnimationFrame(() => requestAnimationFrame(() => setTimeout(once, 150)));
                        setTimeout(once, 2000);
                    } catch (err) {
                        if (offChart) try { offChart.dispose(); } catch (_) { }
                        try { document.body.removeChild(div); } catch (_) { }
                        reject(err);
                    }
                });
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  SPLIT ZIP EXPORT: bg-only + text-only
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async exportSplitZip() {
                if (!this.chart) return;
                if (typeof JSZip === 'undefined') { alert('JSZip æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢'); return; }
                const btn = document.getElementById('export-zip-btn');
                const statusEl = document.getElementById('export-status');
                const fileName = document.getElementById('cfg-filename').value.trim() || 'ECharts_Table';
                const pr = this.getPixelRatio();
                const label = pr >= 8 ? '8K' : '4K';
                const raw = document.getElementById('data-input').value;
                const data = this.parseInputData(raw);
                if (!data) { if (statusEl) statusEl.textContent = 'âš ï¸ æ— æ•°æ®å¯å¯¼å‡º'; return; }
                const config = this.getConfig();
                const radius = (config.borderRadius || 0) * pr;

                btn.disabled = true; btn.textContent = 'â³ å¯¼å‡ºä¸­...';
                if (statusEl) { statusEl.textContent = 'æ­£åœ¨æ¸²æŸ“ã€Œä»…èƒŒæ™¯ã€...'; statusEl.style.color = '#86868b'; }

                try {
                    // Helper: render offscreen + apply round corner clip â†’ returns base64
                    const renderAndClip = (renderMode, bgColor) =>
                        this._renderOffscreen(data, config, renderMode, bgColor, pr).then(b64 =>
                            new Promise(res => {
                                const url = 'data:image/png;base64,' + b64;
                                this._clipRoundedCorner(url, radius, blob => {
                                    const reader = new FileReader();
                                    reader.onload = () => res(reader.result.split(',')[1]);
                                    reader.readAsDataURL(blob);
                                });
                            })
                        );

                    // Step 1: background only
                    const bgB64 = await renderAndClip('bgOnly', config.transparent ? 'transparent' : (config.bgColor || '#ffffff'));
                    if (statusEl) statusEl.textContent = 'æ­£åœ¨æ¸²æŸ“ã€Œä»…æ–‡å­—ã€...';

                    // Step 2: text only
                    const txtB64 = await renderAndClip('textOnly', 'transparent');
                    if (statusEl) statusEl.textContent = 'æ­£åœ¨æ‰“åŒ… ZIP...';

                    // Step 3: pack ZIP
                    const zip = new JSZip();
                    const folder = zip.folder(fileName);
                    folder.file(`${fileName}_ä»…èƒŒæ™¯_${label}.png`, bgB64, { base64: true });
                    folder.file(`${fileName}_ä»…æ–‡å­—_${label}.png`, txtB64, { base64: true });
                    const blob = await zip.generateAsync({ type: 'blob' });
                    saveAs(blob, `${fileName}_èƒŒæ™¯ä¸æ–‡å­—_${label}.zip`);

                    if (statusEl) { statusEl.textContent = 'âœ… ZIP å¯¼å‡ºæˆåŠŸï¼ˆå«2å¼ å›¾ï¼‰'; statusEl.style.color = '#34c759'; }
                } catch (e) {
                    if (statusEl) { statusEl.textContent = 'âŒ å¯¼å‡ºå¤±è´¥: ' + (e.message || e); statusEl.style.color = '#ff3b30'; }
                } finally {
                    btn.disabled = false; btn.textContent = 'ğŸ“¦ å¯¼å‡ºã€Œä»…èƒŒæ™¯ã€+ã€Œä»…æ–‡å­—ã€ZIP';
                }
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  AUTO-FIT CANVAS TO DATA
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            autoFitToData(data) {
                if (!data) return;
                const cols = data.headers.length;
                const rows = data.rows.length;
                const config = this.getConfig();
                const ROW_H = config.rowHeight;
                const TOTAL_ROWS = rows + 1;
                // idealW: canvas width = col count * base width (no horizontal margin offset since left is always 0)
                const idealW = Math.max(200, cols * 180);
                const tableH = TOTAL_ROWS * ROW_H;
                // Canvas height = table rows + top/bottom margins
                const idealH = tableH + config.marginTop + config.marginBottom;

                if (this.state.width !== idealW || this.state.height !== idealH) {
                    this.state.width = idealW; this.state.height = idealH;
                    const dom = document.getElementById('chart-container');
                    dom.style.width = idealW + 'px'; dom.style.height = idealH + 'px';
                    if (this.chart) this.chart.resize({ width: idealW, height: idealH });
                    this.autoFit();
                }
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  CANVAS SIZE
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            applyCanvasSize() {
                // Canvas size is always auto-fit. This function is kept for backward compat.
                this.render(true);
            },

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //  ZOOM & PAN CONTROLS
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            zoom(delta) {
                this.state.viewScale = Math.min(5, Math.max(0.05, this.state.viewScale + delta));
                this.updateTransform();
            },
            resetZoom() { this.state.viewScale = 1; this.state.viewX = 0; this.state.viewY = 0; this.updateTransform(); },
            autoFit() {
                const wrap = document.getElementById('preview-stage');
                this.state.viewScale = Math.min(
                    (wrap.clientWidth - 80) / this.state.width,
                    (wrap.clientHeight - 80) / this.state.height
                );
                this.state.viewX = 0; this.state.viewY = 0;
                this.updateTransform();
            },
            updateTransform() {
                const dom = document.getElementById('chart-container');
                dom.style.transform = `translate(${this.state.viewX}px, ${this.state.viewY}px) scale(${this.state.viewScale})`;
                document.getElementById('zoom-level').textContent = Math.round(this.state.viewScale * 100) + '%';
            },

            initCanvasControl() {
                const stage = document.getElementById('preview-stage');
                const chartDom = document.getElementById('chart-container');
                let isDragging = false, startX, startY, isSpacePressed = false;

                stage.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.zoom(e.deltaY > 0 ? -0.05 : 0.05);
                }, { passive: false });

                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !e.repeat && !['TEXTAREA', 'INPUT'].includes(document.activeElement.tagName)) {
                        isSpacePressed = true; stage.style.cursor = 'grab'; chartDom.style.pointerEvents = 'none';
                    }
                });
                window.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') { isSpacePressed = false; stage.style.cursor = ''; chartDom.style.pointerEvents = 'auto'; }
                });

                stage.addEventListener('mousedown', (e) => {
                    if (e.button === 1 || (e.button === 0 && isSpacePressed) || (e.button === 0 && e.target === stage)) {
                        isDragging = true;
                        startX = e.clientX - this.state.viewX;
                        startY = e.clientY - this.state.viewY;
                        stage.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });
                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    this.state.viewX = e.clientX - startX;
                    this.state.viewY = e.clientY - startY;
                    this.updateTransform();
                });
                window.addEventListener('mouseup', () => {
                    if (isDragging) { isDragging = false; stage.style.cursor = isSpacePressed ? 'grab' : ''; }
                });
            },
        };

        window.onload = () => App.init();
    </script>

    <!-- hidden backward-compat: cfg-canvas always 'auto' -->
    <select id="cfg-canvas" style="display:none;">
        <option value="auto" selected>auto</option>
    </select>
    <div id="custom-canvas-inputs" style="display:none;"></div>

</body>

</html>